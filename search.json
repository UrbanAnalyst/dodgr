[{"path":"https://UrbanAnalyst.github.io/dodgr/CONDUCT.html","id":null,"dir":"","previous_headings":"","what":"Contributor Code of Conduct","title":"Contributor Code of Conduct","text":"contributors maintainers project, pledge respect people contribute reporting issues, posting feature requests, updating documentation, submitting pull requests patches, activities. committed making participation project harassment-free experience everyone, regardless level experience, gender, gender identity expression, sexual orientation, disability, personal appearance, body size, race, ethnicity, age, religion. Examples unacceptable behavior participants include use sexual language imagery, derogatory comments personal attacks, trolling, public private harassment, insults, unprofessional conduct. Project maintainers right responsibility remove, edit, reject comments, commits, code, wiki edits, issues, contributions aligned Code Conduct. Project maintainers follow Code Conduct may removed project team. Instances abusive, harassing, otherwise unacceptable behavior may reported opening issue contacting one project maintainers. Code Conduct adapted Contributor Covenant (https:contributor-covenant.org), version 1.0.0, available https://contributor-covenant.org/version/1/0/0/","code":""},{"path":[]},{"path":"https://UrbanAnalyst.github.io/dodgr/CONTRIBUTING.html","id":"opening-issues","dir":"","previous_headings":"","what":"Opening issues","title":"Contributing to dodgr","text":"easiest way note behavioural curiosities request new features opening github issue.","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/CONTRIBUTING.html","id":"development-guidelines","dir":"","previous_headings":"","what":"Development guidelines","title":"Contributing to dodgr","text":"’d like contribute changes dodgr, use GitHub flow proposing, submitting, reviewing, accepting changes. haven’t done , ’s nice overview git , well best practices submitting pull requests . dodgr coding style diverges somewhat commonly used R style guide, primarily following two ways, improve code readability: (1) curly braces vertically aligned: (2) Also highlighted code additional whitespace permeates dodgr code. Words text separated whitespace, code words : natural result one ends writing space function (). ’s .","code":"this <- function () {     x <- 1 } this <- function(){     x <- 1 } this <- function1 (function2 (x)) this <- function1(function2(x)) this <- function ()"},{"path":"https://UrbanAnalyst.github.io/dodgr/CONTRIBUTING.html","id":"code-of-conduct","dir":"","previous_headings":"","what":"Code of Conduct","title":"Contributing to dodgr","text":"want encourage warm, welcoming, safe environment contributing project. See code conduct information.","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/articles/dists-categorical.html","id":"full-distance-information-for-edge-categories","dir":"Articles","previous_headings":"","what":"1 Full Distance Information for Edge Categories","title":"Aggregating distances along categories of edges","text":"“default” interface dodgr_dists_categorical function requires three mandatory parameters dodgr_distances, weighted graph distances calculated; vector points distances calculated; corresponding vector points. dodgr_distances, arguments can either vertex identifiers (generally from_id to_id columns input graph), two-column coordinates spatial graphs. following code illustrates procedure, using internal data set, hampi, settlement Hampi middle national park Deccan Plains India. following code also reduces network largest connected component , ensure points mutually reachable. network 8 distinct edge types. Submitting graph function, calculating pairwise distances points, gives following result: result dedicated class, dodgr_dists_categorical, list matrices, one distinct edge type. class enables convenient summary method converts data aggregate distances along category edges overall proportions: statistics clearly highlight fact Hampi pedestrian town - ways either paths tracks, new “secondary” ways access vehicles.","code":"graph <- weight_streetnet (hampi, wt_profile = \"foot\") graph <- graph [graph$component == 1, ] graph$edge_type <- graph$highway table (graph$edge_type) ##  ##         path      primary  residential    secondary      service        steps  ##         2767          106           32          560          184           28  ##        track unclassified  ##          518          454 v <- dodgr_vertices (graph) from <- to <- v$id d <- dodgr_dists_categorical (graph, from, to) class (d) ## [1] \"list\"                    \"dodgr_dists_categorical\" length (d) ## [1] 9 sapply (d, dim) ##      distances path primary residential secondary service steps track ## [1,]      2270 2270    2270        2270      2270    2270  2270  2270 ## [2,]      2270 2270    2270        2270      2270    2270  2270  2270 ##      unclassified ## [1,]         2270 ## [2,]         2270 summary (d) ## Proportional distances along each kind of edge: ##   path: 0.5133 ##   primary: 0.016 ##   residential: 4e-04 ##   secondary: 0.1561 ##   service: 0.0607 ##   steps: 0.0018 ##   track: 0.1018 ##   unclassified: 0.1499"},{"path":"https://UrbanAnalyst.github.io/dodgr/articles/dists-categorical.html","id":"proportional-distances-along-each-edge-category","dir":"Articles","previous_headings":"","what":"2. Proportional Distances along each Edge Category","title":"Aggregating distances along categories of edges","text":"summary results like immediately desired, proportions_only parameter can used dodgr_dists_categorical() function directly return : Queries proportions_only = TRUE constructed different way underlying C++ code avoids storing full list matrices memory. jobs, translate faster queries, illustrated following benchmark: default value proportions_only = FALSE used additional information distance matrices required desired. Examples additional information include parameters quantifying distributions various distance metrics, examined .","code":"dodgr_dists_categorical (graph, from, to,                          proportions_only = TRUE) ##         path      primary  residential    secondary      service        steps  ## 0.5132876816 0.0160100421 0.0004094553 0.1561029152 0.0606822224 0.0018216492  ##        track unclassified  ## 0.1017594638 0.1499265705 bench::mark (full = dodgr_dists_categorical (graph, from, to),              prop_only = dodgr_dists_categorical (graph, from, to,                                                   proportions_only = TRUE),              check = FALSE, time_unit = \"s\") [, 1:3] ## # A tibble: 2 × 3 ##   expression   min median ##   <bch:expr> <dbl>  <dbl> ## 1 full       0.489  0.492 ## 2 prop_only  0.263  0.264"},{"path":"https://UrbanAnalyst.github.io/dodgr/articles/dists-categorical.html","id":"proportional-distances-within-a-threshold-distance","dir":"Articles","previous_headings":"","what":"3. Proportional Distances within a Threshold Distance","title":"Aggregating distances along categories of edges","text":"third final use dodgr_dists_categorical function dlimit parameter, used specify distance threshold categorical distances aggregated. useful examine relative proportions different edges types necessary travelling directions away point vertex graph. dlimit parameter specified, parameter ignored, distances aggregated along possible routes away point, specified dlimit. value dlimit must specified relative edge distance values contained input graph. spatial graphs obtained dodgr_streetnet() dodgr_streetnet_sc(), example, well internal hampi data, distances metres, dlimit must specified metres. result single matrix row represents one points, one column aggregate distances edge type, plus initial column overall distances. following code illustrates: row names resultant data.frame vertex identifiers specified parameter. results can easily combined spatial information vertices obtained dodgr_vertices() function generate spatial maps relative proportions around point graph network. Summary statistics can also readily extracted, example,  Trips along paths roughly evenly distributed 0 1. contrast, proportions trips along service ways – used facilitate motorised vehicular access otherwise car-free area Hampi, India – distinctly different:  distributions provide detailed nuanced insights provided overall summary functions , revealed overall respective relative proportions 0.51 0.06 paths service ways. results within distance threshold reveal distributional forms proportional distances differ much aggregate values, aspects function provide distinct insights proportional distances along categories edge types. Finally, use function also utilizes distinct difference underlying C++ code even efficient previous case proportional distances. following code benchmarks three modes: Finally, note efficiency distance-threshold queries scales non-linearly increases dlimit, queries quickly becoming less efficient larger values dlimit.","code":"dlimit <- 2000 # in metres d <- dodgr_dists_categorical (graph, from, dlimit = dlimit) dim (d) ## [1] 2270    9 head (d) ##             distance     path primary residential secondary   service steps ## 339318500  12085.012 9382.223       0           0         0 2617.6145     0 ## 339318502   4136.151 3522.017       0           0         0  614.1342     0 ## 2398958028  4153.900 3539.766       0           0         0  614.1342     0 ## 1427116077  6173.306 5144.681       0           0         0  961.4988     0 ## 7799710916  4191.346 3577.212       0           0         0  614.1342     0 ## 339318503   6215.252 5601.117       0           0         0  614.1342     0 ##            track unclassified ## 339318500      0     85.17409 ## 339318502      0      0.00000 ## 2398958028     0      0.00000 ## 1427116077     0     67.12613 ## 7799710916     0      0.00000 ## 339318503      0      0.00000 hist (d$path / d$distance,       xlab = \"Relative proportions of trips along paths\", main = \"\") hist (d$service / d$distance,       xlab = \"Relative proportions of trips along service ways\", main = \"\") bench::mark (full = dodgr_dists_categorical (graph, from, to),              prop_only = dodgr_dists_categorical (graph, from, to,                                                   proportions_only = TRUE),              dlimit = dodgr_dists_categorical (graph, from, dlimit = 2000),              check = FALSE, time_unit = \"s\") [, 1:3] ## # A tibble: 3 × 3 ##   expression    min median ##   <bch:expr>  <dbl>  <dbl> ## 1 full       0.492  0.496  ## 2 prop_only  0.266  0.266  ## 3 dlimit     0.0701 0.0727"},{"path":"https://UrbanAnalyst.github.io/dodgr/articles/dodgr.html","id":"background-directed-graphs","dir":"Articles","previous_headings":"","what":"1 Background: Directed Graphs","title":"dodgr","text":"dodgr R package calculating Distances Directed Graphs. efficiently, able process larger graphs many comparable R packages. Skip straight Intro know directed graphs (maybe make brief stop-Dual-Weighted Directed Graphs .) Directed graphs ones “distance” (equivalent measure) B necessarily equal B . Fig. 1, example, weights graph vertices (, B, C, D) differ depending direction travel, possible traverse entire graph anti-clockwise direction.  Graphs dodgr represented simple flat data.frame objects, graph Fig. 1, presuming edge weights take values 1, 2, 3, , primary function dodgr dodgr_dists, calculates pair-wise shortest distances vertices graph.","code":"##   from to d ## 1    A  B 1 ## 2    B  A 2 ## 3    B  C 1 ## 4    B  D 3 ## 5    C  B 2 ## 6    C  D 1 ## 7    D  C 2 ## 8    D  A 1 dodgr_dists (graph) ##   A B C D ## A 0 1 2 3 ## B 2 0 1 2 ## C 2 2 0 1 ## D 1 2 2 0 dodgr_dists (graph, from = c (\"A\", \"C\"), to = c (\"B\", \"C\", \"D\")) ##   B C D ## A 1 2 3 ## C 2 0 1"},{"path":"https://UrbanAnalyst.github.io/dodgr/articles/dodgr.html","id":"dual-weighted-directed-graphs","dir":"Articles","previous_headings":"1 Background: Directed Graphs","what":"1.1 Dual-Weighted Directed Graphs","title":"dodgr","text":"Shortest-path distances weighted graphs can calculated using number R packages, igraph e1071. dodgr comes ability trace paths dual-weighted directed graphs, illustrated Fig. 2.  Dual-weighted directed graphs common many areas, foremost example routing street networks. Routes street networks depends mode transport: route pedestrian might take generally differ markedly route person might take behind wheel automobile. Routing street networks thus generally requires edge specified two weights distances: one quantifying physical distance, second weighted version reflecting mode transport (preferential weighting). dodgr calculates shortest paths using one set weights (called “weights” anything else starting “w”), returns actual lengths using second set weights (called “distances”, anything else starting “d”). weights specified, distances alone used routing final distance calculations. Consider weights distances Fig. 2 black grey lines, respectively, latter equal one. case, graph associated shortest distances , Note even though shortest “distance” D actually →\\toB→\\toD distance 2, path weighted distance 1 + 3 = 4. shortest weighted path →\\toB→\\toC→\\toD, distance weighted unweighted 1 + 1 + 1 = 3. Thus d(,D) = 3 2.","code":"##   from to w d ## 1    A  B 1 1 ## 2    B  A 2 1 ## 3    B  C 1 1 ## 4    B  D 3 1 ## 5    C  B 2 1 ## 6    C  D 1 1 ## 7    D  C 2 1 ## 8    D  A 1 1 ##   A B C D ## A 0 1 2 2 ## B 1 0 1 1 ## C 2 1 0 1 ## D 1 2 1 0"},{"path":"https://UrbanAnalyst.github.io/dodgr/articles/dodgr.html","id":"introduction-to-dodgr","dir":"Articles","previous_headings":"","what":"2 Introduction to dodgr","title":"dodgr","text":"Although package intentionally developed adaptable kinds networks, applications illustrated concern street networks, also illustrate several helper functions package offers working street networks. basic graph object dodgr nevertheless arbitrary, need minimally contain three four columns demonstrated simple examples outset. package may used calculate matrix distances given set geographic coordinates. can start simply generating random coordinates, case within bounding box defining city York U.K. following lines download street network within bounding box, weight pedestrian travel, use weighted network calculate pairwise distances xypoints. result matrix 1000--1000 distances 57km long, measured along routes weighted optimal pedestrian travel. case, single call dodgr_distances() automatically downloaded entire street network York calculated one million shortest-path distances, 30 seconds.","code":"bb <- osmdata::getbb (\"york uk\") npts <- 1000 xy <- apply (bb, 1, function (i) min (i) + runif (npts) * diff (i)) bb; head (xy) ##         min        max ## x -1.241536 -0.9215361 ## y 53.799056 54.1190555 ##               x        y ## [1,] -1.1713502 53.89409 ## [2,] -1.2216108 54.01065 ## [3,] -1.0457199 53.83613 ## [4,] -0.9384666 53.93545 ## [5,] -0.9445541 53.89436 ## [6,] -1.1207099 54.01262 net <- dodgr_streetnet (bb) net <- weight_streetnet (net, wt_profile = \"foot\") system.time (             d <- dodgr_dists (net, from = xy, to = xy)             ) ##    user  system elapsed  ##  38.828   0.036   5.424 dim (d); range (d, na.rm = TRUE) ## [1] 1000 1000 ## [1]     0.00 57021.18"},{"path":"https://UrbanAnalyst.github.io/dodgr/articles/dodgr.html","id":"graphs-and-street-networks","dir":"Articles","previous_headings":"","what":"3 Graphs and Street Networks","title":"dodgr","text":"Although code short fast, users probably want control graphs routing possibilities. illustrate, remainder vignette analyses much smaller street network Hampi, Karnataka, India, included dodgr package dataset hampi. data set may re-created following single line: equivalent version bundled package: streetnet sf (Simple Features) object containing 189 LINESTRING geometries. words, ’s got sf representation 189 street segments. R package osmplotr can used visualise street network (help magrittr pipe operator, %>%):  sf class data representing street network Hampi can converted flat data.frame object Note actual graph contains around 30 times many edges streets, indicating street composed average around 30 individual segments. individual points vertices segments can extracted , see OpenStreetMap representation streets Hampi 189 line segments 2,987 unique points 6,096 edges points. number edges per vertex entire network thus, simple straight line two edges intermediate nodes, thus indicates network ’s entirety quite simple. data.frame resulting weight_streetnet() dodgr uses calculate shortest path routes, described , following brief description weighting street networks.","code":"hampi <- dodgr_streetnet (\"hampi india\") class (hampi) ## [1] \"sf\"         \"data.frame\" class (hampi$geometry) ## [1] \"sfc_LINESTRING\" \"sfc\" dim (hampi) ## [1] 236  15 library (osmplotr) library (magrittr) map <- osm_basemap (hampi, bg = \"gray95\") %>%     add_osm_objects (hampi, col = \"gray5\") %>%     add_axes () %>%     print_osm_map () graph <- weight_streetnet (hampi, wt_profile = \"foot\") dim (graph) ## [1] 6813   15 head (graph) ##   geom_num edge_id    from_id from_lon from_lat      to_id   to_lon   to_lat ## 1        1       1  339318500 76.47491 15.34167  339318502 76.47612 15.34173 ## 2        1       2  339318502 76.47612 15.34173  339318500 76.47491 15.34167 ## 3        1       3  339318502 76.47612 15.34173 2398958028 76.47621 15.34174 ## 4        1       4 2398958028 76.47621 15.34174  339318502 76.47612 15.34173 ## 5        1       5 2398958028 76.47621 15.34174 1427116077 76.47628 15.34179 ## 6        1       6 1427116077 76.47628 15.34179 2398958028 76.47621 15.34174 ##            d d_weighted highway   way_id component      time time_weighted ## 1 129.761207 129.761207    path 28565950         1 93.428069     93.428069 ## 2 129.761207 129.761207    path 28565950         1 93.428069     93.428069 ## 3   8.874244   8.874244    path 28565950         1  6.389455      6.389455 ## 4   8.874244   8.874244    path 28565950         1  6.389455      6.389455 ## 5   9.311222   9.311222    path 28565950         1  6.704080      6.704080 ## 6   9.311222   9.311222    path 28565950         1  6.704080      6.704080 vt <- dodgr_vertices (graph) head(vt) ##            id        x        y component n ## 1   339318500 76.47491 15.34167         1 0 ## 2   339318502 76.47612 15.34173         1 1 ## 4  2398958028 76.47621 15.34174         1 2 ## 6  1427116077 76.47628 15.34179         1 3 ## 8  7799710916 76.47634 15.34184         1 4 ## 10  339318503 76.47641 15.34190         1 5 dim (vt) ## [1] 3337    5 nrow (graph) / nrow (vt) ## [1] 2.041654"},{"path":"https://UrbanAnalyst.github.io/dodgr/articles/dodgr.html","id":"graph-components","dir":"Articles","previous_headings":"3 Graphs and Street Networks","what":"3.1 Graph Components","title":"dodgr","text":"foregoing graph object returned weight_streetnet() also includes $component column enumerating distinct inter-connected components graph. Components numbered order decreasing size, $component = 1 always denoting largest component. case, component contains 3,934 edges, representing 65% graph. clearly three distinct components, number may much larger larger graphs, may obtained , Component numbers can determined types graph dodgr_components() function. example, following lines reduce previous graph minimal (non-spatial) structure four columns, (re-)calculate fifth column $components: component column column can used select filter component graph. particularly useful ensure routing calculations consider connected vertices simply removing minor components: explored (Distance Matrices).","code":"table (graph$component) ##  ##    1    2    3  ## 4649 2066   98 length (unique (graph$component)) ## [1] 3 cols <- c (\"edge_id\", \"from_id\", \"to_id\", \"d\") graph_min <- graph [, which (names (graph) %in% cols)] graph_min <- dodgr_components (graph_min) head (graph_min) ##   edge_id    from_id      to_id          d component ## 1       1  339318500  339318502 129.761207         1 ## 2       2  339318502  339318500 129.761207         1 ## 3       3  339318502 2398958028   8.874244         1 ## 4       4 2398958028  339318502   8.874244         1 ## 5       5 2398958028 1427116077   9.311222         1 ## 6       6 1427116077 2398958028   9.311222         1 graph_connected <- graph [graph$component == 1, ]"},{"path":"https://UrbanAnalyst.github.io/dodgr/articles/dodgr.html","id":"weighting-profiles","dir":"Articles","previous_headings":"3 Graphs and Street Networks","what":"3.2 Weighting Profiles","title":"dodgr","text":"Dual-weights street networks generally obtained multiplying distance segment weighting factor reflecting type highway. demonstrated , can done easily within dodgr weight_streetnet() function, applies named weighting profiles included dodgr package OpenStreetMap networks extracted osmdata package. function uses internal data dodgr::weighting_profiles, list three items: weighting_profiles; surface_speeds; penalties data used calculate routing times dodgr_times function, detailed additional vignette. aspects relevant distances profiles , assign preferential weights distinct type highway. profile defined series percentage weights quantifying highway-type preferences particular mode travel. distinct types highways within Hampi graph obtained can tabulated : Hampi unlike human settlements planet Unesco World Heritage area automobiles generally prohibited. Accordingly, numbers \"footway\", \"path\", \"pedestrian\" ways far exceed typical categories denoting automobile traffic (\"primary\", \"residential\", \"tertiary\") also possible use types (non-OpenStreetMap) street networks, example os_roads_bristol data provided package. “OS” U.K. Ordnance Survey, data provided Simple Features (sf) data.frame decidedly different structure osmdata data.frame objects: latter may converted dodgr network first specifying weighting profile, based formOfWay column: resultant net object contains street network os_roads_bristol weighted specified profile, format suitable submission dodgr routine.","code":"wp <- weighting_profiles$weighting_profiles names (wp) ## [1] \"name\"      \"way\"       \"value\"     \"max_speed\" class (wp) ## [1] \"data.frame\" unique (wp$name) ##  [1] \"foot\"       \"horse\"      \"wheelchair\" \"bicycle\"    \"moped\"      ##  [6] \"motorcycle\" \"motorcar\"   \"goods\"      \"hgv\"        \"psv\" wp [wp$name == \"foot\", ] ##    name            way value max_speed ## 1  foot       motorway  0.00        NA ## 2  foot          trunk  0.40        NA ## 3  foot        primary  0.50         5 ## 4  foot      secondary  0.60         5 ## 5  foot       tertiary  0.70         5 ## 6  foot   unclassified  0.80         5 ## 7  foot    residential  0.90         5 ## 8  foot        service  0.90         5 ## 9  foot          track  0.95         5 ## 10 foot       cycleway  0.95         5 ## 11 foot           path  1.00         5 ## 12 foot          steps  0.80         2 ## 13 foot          ferry  0.20         5 ## 14 foot  living_street  0.95         5 ## 15 foot      bridleway  1.00         5 ## 16 foot        footway  1.00         5 ## 17 foot     pedestrian  1.00         5 ## 18 foot  motorway_link  0.00        NA ## 19 foot     trunk_link  0.40        NA ## 20 foot   primary_link  0.50         5 ## 21 foot secondary_link  0.60         5 ## 22 foot  tertiary_link  0.70         5 table (graph$highway) ##  ## living_street          path       primary   residential     secondary  ##            20          3557           430           196           560  ##       service         steps         track  unclassified  ##           256           108           914           772 names (hampi) # many fields manually removed to reduce size of this object ##  [1] \"osm_id\"        \"bicycle\"       \"covered\"       \"foot\"          ##  [5] \"highway\"       \"incline\"       \"motorcar\"      \"motorcycle\"    ##  [9] \"motor_vehicle\" \"oneway\"        \"surface\"       \"tracktype\"     ## [13] \"tunnel\"        \"width\"         \"geometry\" names (os_roads_bristol) ##  [1] \"fictitious\" \"identifier\" \"class\"      \"roadNumber\" \"name1\"      ##  [6] \"name1_lang\" \"name2\"      \"name2_lang\" \"formOfWay\"  \"length\"     ## [11] \"primary\"    \"trunkRoad\"  \"loop\"       \"startNode\"  \"endNode\"    ## [16] \"structure\"  \"nameTOID\"   \"numberTOID\" \"function.\"  \"geometry\" colnm <- \"formOfWay\" table (os_roads_bristol [[colnm]]) ##  ## Collapsed Dual Carriageway           Dual Carriageway  ##                         14                          6  ##         Single Carriageway                  Slip Road  ##                          1                          8 wts <- data.frame (name = \"custom\",                    way = unique (os_roads_bristol [[colnm]]),                    value = c (0.1, 0.2, 0.8, 1)) net <- weight_streetnet (os_roads_bristol, wt_profile = wts,                          type_col = colnm, id_col = \"identifier\")"},{"path":"https://UrbanAnalyst.github.io/dodgr/articles/dodgr.html","id":"random-sub-graphs","dir":"Articles","previous_headings":"3 Graphs and Street Networks","what":"3.3 Random Sub-Graphs","title":"dodgr","text":"dodgr packages includes function select random connected portion graph including specified number vertices. function used compare_heaps() function described , also useful general statistical analyses large graphs may otherwise take long compute. random sample around twice many edges vertices, accordance statistics calculated .","code":"graph_sub <- dodgr_sample (graph, nverts = 100) nrow (graph_sub) ## [1] 201 nrow (dodgr_vertices (graph_sub)) ## [1] 100"},{"path":"https://UrbanAnalyst.github.io/dodgr/articles/dodgr.html","id":"distance-matrices-dodgr_dists","dir":"Articles","previous_headings":"","what":"4 Distance Matrices: dodgr_dists()","title":"dodgr","text":"demonstrated outset, entire network can simply submitted dodgr_distances(), case square matrix returned containing pair-wise distances vertices. graph York return square matrix around 90,000-times-90,000 (8 billion) distances. might possible computers, possibly neither recommended desirable. dodgr_distances() function accepts additional arguments defining points distances calculated. provided, square matrix returned pair-wise distances listed points.","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/articles/dodgr.html","id":"aligning-routing-points-to-graphs","dir":"Articles","previous_headings":"4 Distance Matrices: dodgr_dists()","what":"4.1 Aligning Routing Points to Graphs","title":"dodgr","text":"spatial graphs—, containing columns latitudes longitudes (“x” “y”)—routing points can represented simple matrix arbitrary latitudes longitudes (, , “x” “y”). dodgr_distances() map points closest network points, return corresponding shortest-path distances. may illustrated generating random points within bounding box map Hampi. demonstrated , coordinates vertices may extracted dodgr_vertices() function, enabling random points generated following lines: Submitting dodgr_distances() points route generate distance matrix 100 points every point graph: argument also specified, matrix returned rows matching columns matching resultant distances cases NA points sampled entire bounding box, street network near boundaries may cut rest. demonstrated , weight_streetnet() function returns component vector, disconnected edges graph$component > 1, graph$component == 1 always denotes largest connected component. means graph can always reduced single largest component following single line: distance matrix obtained running dodgr_distances graph_connected generally contain NA values, although points may still effectively unreachable due one-way connections (streets). Thus, routing largest connected component directed graph expected yield minimal number NA values, may sometimes zero. Note spatial routing points (expressed /arguments) case mapped nearest vertices graph_connected, rather potentially closer nearest points full graph. may make spatial mapping routing points less accurate results obtained repeating extraction street network using expanded bounding box. automatic extraction street networks dodgr_distances(), extent bounding box exceeds range routing points (arguments) determined extra parameter expand, quantifying relative extent bounding box exceed spatial range routing points. illustrated following code calculates distances 100 random points: street network precisely encompasses submitted routing points (expand = 0), 4% pairwise distances unable calculated; bounding box expanded 5% larger submitted points, reduced 2.3%, expansion 20%, points can connected. non-spatial graphs, must match precisely vertices named graph . graph considered , vertex names contained columns, from_id to_id. minimum dodgr graph requires , case values submitted dodgr_dists() (, given) must directly name vertices from_id to_id columns graph. illustrated following code: result 10--20 matrix distances named graph vertices.","code":"vt <- dodgr_vertices (graph) n <- 100 # number of points to generate xy <- data.frame (x = min (vt$x) + runif (n) * diff (range (vt$x)),                   y = min (vt$y) + runif (n) * diff (range (vt$y))) d <- dodgr_dists (graph, from = xy) dim (d); range (d, na.rm = TRUE) ## [1]  100 3337 ## [1]     0.00 14915.93 d <- dodgr_dists (graph, from = xy, to = xy [1:10, ]) dim (d) ## [1] 100  10 graph_connected <- graph [graph$component == 1, ] bb <- osmdata::getbb (\"york uk\") npts <- 100 xy <- apply (bb, 1, function (i) min (i) + runif (npts) * diff (i))  routed_points <- function (expand = 0, pts) {      gr0 <- dodgr_streetnet (pts = pts, expand = expand) %>%         weight_streetnet ()     d0 <- dodgr_dists (gr0, from = pts)     length (which (is.na (d0))) / length (d0) } vapply (c (0, 0.05, 0.1, 0.2), function (i) routed_points (i, pts = xy),         numeric (1)) ## [1] 0.04007477 0.02326452 0.02131992 0.00000000 head (graph [, names (graph) %in% c (\"from_id\", \"to_id\", \"d\")]) ##      from_id      to_id          d ## 1  339318500  339318502 129.761207 ## 2  339318502  339318500 129.761207 ## 3  339318502 2398958028   8.874244 ## 4 2398958028  339318502   8.874244 ## 5 2398958028 1427116077   9.311222 ## 6 1427116077 2398958028   9.311222 graph_min <- graph [, names (graph) %in% c (\"from_id\", \"to_id\", \"d\")] fr <- sample (graph_min$from_id, size = 10) # 10 random points to <- sample (graph_min$to_id, size = 20) d <- dodgr_dists (graph_min, from = fr, to = to) dim (d) ## [1] 10 20"},{"path":"https://UrbanAnalyst.github.io/dodgr/articles/dodgr.html","id":"shortest-path-calculations-priority-queues","dir":"Articles","previous_headings":"4 Distance Matrices: dodgr_dists()","what":"4.2 Shortest Path Calculations: Priority Queues","title":"dodgr","text":"dodgr uses internal library Shane Saunders (2004) calculation shortest paths using variety priority queues (see Miller 1960 overview). context shortest paths, priority queues determine order graph traversed (Tarjan 1983), choice priority queue can considerable effect computational efficiency different kinds graphs (Johnson 1977). contrast dodgr, R packages shortest path calculations use priority queues, may often less efficient. Shortest path distances can calculated dodgr priority queues use following heaps: Binary heaps; Fibonacci heaps (Fredman Tarjan 1987); Trinomial extended trinomial heaps (Takaoka 2000); 2-3 heaps (Takaoka 1999). Differences heaps operate often largely extraneous direct application routing algorithms, even though heap choice may strongly affect performance. avoid users needing know anything algorithmic details, dodgr provides function compare_heaps() particular graph may submitted order determine optimal kind heap. comparisons actually made randomly selected sub-component graph containing defined number vertices (default 1,000, entire graph contains fewer 1,000 vertices). key column data.frame relative, quantifies relative performance test relation best given score 1. dodgr using default heap = \"BHeap\", binary heap priority queue, performs faster igraph (Csardi Nepusz 2006) graphs. Different kind graphs perform differently different priority queue structures, function enables users empirically discern optimal heap kind graph. Note, however, entirely fair comparison, dodgr calculates dual-weighted distances, whereas igraph—indeed R packages—directly calculate distances based single set weights. Implementing dual-weighted routing cases requires explicitly re-tracing paths summing second set weights along path. time comparison case strongly favour dodgr. Moreover, dodgr can convert graphs contracted form removing redundant vertices, detailed following section. greatly improves performance respect igraph. wishing explicit comparisons , following code generates igraph equivalent dodgr_distances(), although course single-weighted graphs :","code":"compare_heaps (graph, nverts = 100) ## Loading required namespace: bench ## Loading required namespace: igraph ## # A tibble: 11 × 6 ##    expression                 min   median `itr/sec` mem_alloc `gc/sec` ##    <bch:expr>            <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl> ##  1 BHeap                   1.54ms   1.59ms      627.    45.3KB     12.8 ##  2 FHeap                   1.55ms   1.62ms      610.    45.3KB     13.5 ##  3 TriHeap                 1.57ms   1.64ms      608.    45.3KB     10.5 ##  4 TriHeapExt              1.42ms   1.46ms      676.    48.4KB     15.0 ##  5 Heap23                  1.57ms   1.63ms      611.    45.3KB     12.7 ##  6 BHeap_contracted        1.35ms    1.4ms      705.    20.1KB     12.7 ##  7 FHeap_contracted        1.37ms   1.42ms      698.    20.1KB     15.0 ##  8 TriHeap_contracted      1.37ms   1.42ms      696.    20.1KB     12.7 ##  9 TriHeapExt_contracted   1.13ms   1.16ms      848.    20.1KB     17.2 ## 10 Heap23_contracted       1.38ms   1.43ms      689.    20.1KB     15.0 ## 11 igraph                703.02µs 743.38µs     1333.   485.2KB     17.4 v <- dodgr_vertices (graph) pts <- sample (v$id, 1000) igr <- dodgr_to_igraph (graph) d <- igraph::distances (igr, v = pts, to = pts, mode = \"out\")"},{"path":"https://UrbanAnalyst.github.io/dodgr/articles/dodgr.html","id":"graph-contraction","dir":"Articles","previous_headings":"","what":"5 Graph Contraction","title":"dodgr","text":"unique feature dodgr ability remove redundant vertices graphs (see Fig. 3), thereby speeding routing calculations.  Fig. 3(), way get vertex 1 3, 4 5 C. intermediate vertex B redundant routing purposes (precise point) may simply removed, directional edges inserted directly vertices 1 3. yields equivalent contracted graph Fig. 3(B), , example, distance (weight) 1 3 sum previous distances (weights) 1 →\\2 2 →\\3. Note one two edges , say, 3 2 removed, vertex 2 longer redundant (Fig. 3(C)). Different kinds graphs different degrees redundancy, even street networks differ, example dense inner-urban networks generally less redundant less dense extra-urban rural networks. contracted version graph can obtained function dodgr_contract_graph(), illustrated York example . function dodgr_contract_graph() returns contracted version original graph, containing number columns, row representing edge two junction vertices (submitted verts, may may junctions). Relative sizes equivalent removal around 90% edges. difference routing efficiency can seen following code contracting graph similar effect speeding pairwise routing 100 points. routing algorithms scale non-linearly size, relative improvements efficiency even greater larger graphs.","code":"grc <- dodgr_contract_graph (graph) nrow (graph); nrow (grc); nrow (grc) / nrow (graph) ## [1] 6813 ## [1] 748 ## [1] 0.1097901 from <- sample (grc$from_id, size = 100) to <- sample (grc$to_id, size = 100) bench::mark (     full = dodgr_dists (graph, from = from, to = to),     contracted = dodgr_dists (grc, from = from, to = to),     check = FALSE # numeric rounding errors can lead to differences     ) ## # A tibble: 2 × 6 ##   expression      min   median `itr/sec` mem_alloc `gc/sec` ##   <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl> ## 1 full        13.73ms  14.35ms      69.5    1.24MB     2.04 ## 2 contracted   2.56ms   2.65ms     374.   280.59KB     8.45"},{"path":"https://UrbanAnalyst.github.io/dodgr/articles/dodgr.html","id":"routing-on-contracted-graphs","dir":"Articles","previous_headings":"5 Graph Contraction","what":"5.1 Routing on Contracted Graphs","title":"dodgr","text":"Routing often desired defined points, points may inadvertently removed graph contraction. dodgr_contract_graph() function accepts additional argument specifying vertices keep within contracted graph. list vertices must directly match vertex ID values graph. following code illustrates retain specific vertices within contracted graphs: Retaining nominated vertices yields graph considerably edges fully contracted graph excluding vertices. dodgr_distances() function can applied latter graph obtain accurate distances precisely routed points, yet using speed advantages graph contraction.","code":"grc <- dodgr_contract_graph (graph) nrow (grc) ## [1] 748 verts <- sample (dodgr_vertices (graph)$id, size = 100) head (verts) # a character vector ## [1] \"3697937615\" \"3921522990\" \"1204772877\" \"339318467\"  \"2398957584\" ## [6] \"7799710967\" grc <- dodgr_contract_graph (graph, verts) nrow (grc) ## [1] 948"},{"path":"https://UrbanAnalyst.github.io/dodgr/articles/dodgr.html","id":"shortest-paths","dir":"Articles","previous_headings":"","what":"6 Shortest Paths","title":"dodgr","text":"Shortest paths can also extracted dodgr_paths() function. given vectors points, returns nested list , dp [[]] [[j]] contain path [] [j]. paths represented sequences vertex names. Consider following example, columns from_id to_id contain names vertices. extract shortest paths , first take small samples points, submit dodgr_paths(): result (dp) list 10 items, contains 5 vectors. example , spatial graphs, coordinates paths can obtained extracting vertices dodgr_vertices() matching vertex IDs: Paths calculated contracted graphs course fewer vertices calculated full graphs.","code":"dp <- dodgr_paths (graph, from = from, to = to) graph <- weight_streetnet (hampi, wt_profile = \"foot\") head (graph) ##   geom_num edge_id    from_id from_lon from_lat      to_id   to_lon   to_lat ## 1        1       1  339318500 76.47491 15.34167  339318502 76.47612 15.34173 ## 2        1       2  339318502 76.47612 15.34173  339318500 76.47491 15.34167 ## 3        1       3  339318502 76.47612 15.34173 2398958028 76.47621 15.34174 ## 4        1       4 2398958028 76.47621 15.34174  339318502 76.47612 15.34173 ## 5        1       5 2398958028 76.47621 15.34174 1427116077 76.47628 15.34179 ## 6        1       6 1427116077 76.47628 15.34179 2398958028 76.47621 15.34174 ##            d d_weighted highway   way_id component      time time_weighted ## 1 129.761207 129.761207    path 28565950         1 93.428069     93.428069 ## 2 129.761207 129.761207    path 28565950         1 93.428069     93.428069 ## 3   8.874244   8.874244    path 28565950         1  6.389455      6.389455 ## 4   8.874244   8.874244    path 28565950         1  6.389455      6.389455 ## 5   9.311222   9.311222    path 28565950         1  6.704080      6.704080 ## 6   9.311222   9.311222    path 28565950         1  6.704080      6.704080 from <- sample (graph$from_id, size = 10) to <- sample (graph$to_id, size = 5) dp <- dodgr_paths (graph, from = from, to = to) length (dp) ## [1] 10 dp [[1]] [[1]] ##   [1] \"1376768968\" \"7799711098\" \"1376768608\" \"7799711097\" \"7799711095\" ##   [6] \"7799711096\" \"1376769106\" \"7799711094\" \"1376768734\" \"7799711093\" ##  [11] \"1376768365\" \"7799711091\" \"1376768941\" \"7799711092\" \"1376768674\" ##  [16] \"1376768306\" \"7799711090\" \"1376768881\" \"1376768519\" \"7799711085\" ##  [21] \"7799711086\" \"1376768995\" \"1376768635\" \"7799711084\" \"7799711082\" ##  [26] \"7799711083\" \"1376769229\" \"1376768851\" \"7799711081\" \"1376768581\" ##  [31] \"7799711080\" \"7799711078\" \"7799711079\" \"1376769175\" \"1376768789\" ##  [36] \"7799711072\" \"7799711073\" \"1376768419\" \"7799711074\" \"7799711071\" ##  [41] \"1376768908\" \"7799711070\" \"7799711069\" \"1376768547\" \"7799711067\" ##  [46] \"7799711066\" \"7799711068\" \"1376769141\" \"1376768758\" \"7799711065\" ##  [51] \"1376768489\" \"7799711064\" \"7799711063\" \"1376769050\" \"7799711062\" ##  [56] \"7799711061\" \"1376768701\" \"7799711060\" \"7799711059\" \"1376768335\" ##  [61] \"1376768956\" \"7799711058\" \"1376768596\" \"1376769189\" \"1376768804\" ##  [66] \"1376768536\" \"7799711056\" \"7799711057\" \"1376769131\" \"1376768748\" ##  [71] \"7799711055\" \"7799711054\" \"1376768379\" \"1376768866\" \"1376768503\" ##  [76] \"7799711038\" \"7799711037\" \"7799711039\" \"7799711040\" \"7799711041\" ##  [81] \"1376769071\" \"7799711046\" \"7799711045\" \"1376768716\" \"7799711044\" ##  [86] \"7799711043\" \"1376768433\" \"7799711047\" \"1376769009\" \"1376768649\" ##  [91] \"7799711033\" \"1376769241\" \"7799711032\" \"1376768772\" \"7799711031\" ##  [96] \"1376768402\" \"7799711030\" \"7799711029\" \"1376768979\" \"7799711028\" ## [101] \"7799711027\" \"1376768618\" \"7799711026\" \"1376768347\" \"7799711025\" ## [106] \"7799711023\" \"7799711024\" \"1376768922\" \"1376768563\" \"1376769157\" ## [111] \"7799711022\" \"7799711021\" \"1376768683\" \"7799711019\" \"7799711018\" ## [116] \"7799711020\" \"1376768317\" \"1376768891\" \"7799711017\" \"1376768528\" ## [121] \"7799711015\" \"7799711014\" \"7799711016\" \"1376769213\" \"1376768835\" ## [126] \"7799711012\" \"7799711013\" \"1376768471\" \"1376769033\" \"7799711010\" ## [131] \"1376768589\" \"7799711008\" \"7799711007\" \"7799711009\" \"1376769182\" ## [136] \"7799711006\" \"7799711005\" \"1376768796\" \"7799711004\" \"7799711002\" ## [141] \"7799711003\" \"1376768426\" \"7799711000\" \"7799710999\" \"7799711001\" ## [146] \"1376769127\" \"1376768741\" \"7799710998\" \"7799710997\" \"1376768372\" ## [151] \"1376768949\" \"7799710995\" \"7799710994\" \"7799710996\" \"1376768498\" ## [156] \"1376769061\" \"1376768709\" \"7799710986\" \"7799710985\" \"1376768341\" ## [161] \"1376769001\" \"7799710984\" \"7799710983\" \"1376768641\" \"7799710982\" ## [166] \"7799710981\" \"1376769235\" \"7799710980\" \"1376768859\" \"7799710979\" ## [171] \"7799710978\" \"7799710977\" \"1376768395\" \"7799710975\" \"1376768971\" ## [176] \"7799710976\" \"7799710973\" \"1376768611\" \"7799710970\" \"7799710974\" ## [181] \"1376769206\" \"7799710969\" \"7799710968\" \"7799710967\" \"1376768915\" ## [186] \"7799710966\" \"1376768556\" \"1376769150\" \"7799710964\" \"1376768766\" ## [191] \"7799710965\" \"1376768309\" \"7799710963\" \"1376768883\" \"7799710962\" ## [196] \"7799710961\" \"1376768521\" \"1376769110\" \"1376768828\" \"1376768464\" ## [201] \"1376768862\" \"7794426716\" \"1376768398\" \"1376768975\" \"1376768614\" ## [206] \"1376769209\" \"1376768918\" \"1376768559\" \"6410121124\" \"2717241302\" ## [211] \"2717241300\" \"2717241331\" \"2717241317\" \"2717241339\" \"2717241332\" ## [216] \"2717241309\" \"2717241321\" \"2717241306\" \"2717241323\" \"2717241312\" ## [221] \"1376768738\" \"8615528123\" \"8615528122\" \"8615528121\" \"1376768369\" ## [226] \"8615528124\" \"1376768946\" \"1376768586\" \"8615528127\" \"8615528125\" ## [231] \"8615528126\" \"1560930407\" \"8615528128\" \"1376768478\" \"8615528129\" ## [236] \"8615528131\" \"8615528130\" \"1376769039\" \"8615528132\" \"1376768690\" ## [241] \"1376768324\" \"8615528133\" \"1376768985\" \"8615528135\" \"1376768626\" ## [246] \"8615528134\" \"339574829\"  \"8632923846\" \"8632923845\" \"8632923848\" ## [251] \"8632923847\" \"339574828\"  \"8632960961\" \"8632960974\" \"8632960973\" ## [256] \"1560930420\" \"8632960972\" \"8632960971\" \"1560930408\" \"8632960970\" ## [261] \"339574827\"  \"8632960969\" \"8632960968\" \"339574826\"  \"339574825\"  ## [266] \"2717241316\" \"2717241303\" \"8690943487\" \"2717241311\" \"8690943486\" ## [271] \"2717241318\" \"8690943488\" \"8690943489\" \"2717241338\" \"8690943490\" ## [276] \"8690943492\" \"8690943491\" \"2717241298\" \"8690943493\" \"2717241310\" ## [281] \"8690943494\" \"2717241340\" \"8690943497\" \"8690943496\" verts <- dodgr_vertices (graph) path1 <- verts [match (dp [[1]] [[1]], verts$id), ] head (path1) ##              id        x        y component    n ## 2592 1376768968 76.48445 15.33399         1 1304 ## 2590 7799711098 76.48424 15.33401         1 1303 ## 2588 1376768608 76.48420 15.33401         1 1302 ## 2586 7799711097 76.48416 15.33399         1 1301 ## 2584 7799711095 76.48412 15.33397         1 1300 ## 2582 7799711096 76.48409 15.33394         1 1299"},{"path":[]},{"path":"https://UrbanAnalyst.github.io/dodgr/articles/flows.html","id":"flow-aggregation","dir":"Articles","previous_headings":"","what":"1 Flow Aggregation","title":"dodgr flows","text":"first functions aggregates ‘’flows’’ throughout network set origin () destination () points. Flows commonly arise origin-destination matrices used transport studies, may kind generic flows graphs. flow matrix specifies flow pair origin destination points, dodgr_flows_aggregate() function aggregates flows throughout network assigns resultant aggregate flow edge. set nf points origin nt points destination, flows defined simple nf--nt matrix values, following code: flows matrix submitted dodgr_flows_aggregate(), simply appends additional column flows submitted graph: flows zero calculated points graph.","code":"graph <- weight_streetnet (hampi, wt_profile = \"foot\") set.seed (1) from <- sample (graph$from_id, size = 10) to <- sample (graph$to_id, size = 10) flows <- matrix (10 * runif (length (from) * length (to)),     nrow = length (from) ) graph_f <- dodgr_flows_aggregate (graph, from = from, to = to, flows = flows) head (graph_f) ##   geom_num edge_id    from_id from_lon from_lat      to_id   to_lon   to_lat ## 1        1       1  339318500 76.47491 15.34167  339318502 76.47612 15.34173 ## 2        1       2  339318502 76.47612 15.34173  339318500 76.47491 15.34167 ## 3        1       3  339318502 76.47612 15.34173 2398958028 76.47621 15.34174 ## 4        1       4 2398958028 76.47621 15.34174  339318502 76.47612 15.34173 ## 5        1       5 2398958028 76.47621 15.34174 1427116077 76.47628 15.34179 ## 6        1       6 1427116077 76.47628 15.34179 2398958028 76.47621 15.34174 ##            d d_weighted highway   way_id component      time time_weighted flow ## 1 129.761207 129.761207    path 28565950         1 93.428069     93.428069    0 ## 2 129.761207 129.761207    path 28565950         1 93.428069     93.428069    0 ## 3   8.874244   8.874244    path 28565950         1  6.389455      6.389455    0 ## 4   8.874244   8.874244    path 28565950         1  6.389455      6.389455    0 ## 5   9.311222   9.311222    path 28565950         1  6.704080      6.704080    0 ## 6   9.311222   9.311222    path 28565950         1  6.704080      6.704080    0 summary (graph_f$flow) ##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.  ##  0.0000  0.0000  0.0000  0.3164  0.0000  5.1291"},{"path":"https://UrbanAnalyst.github.io/dodgr/articles/flows.html","id":"flow-dispersal","dir":"Articles","previous_headings":"","what":"2 Flow Dispersal","title":"dodgr flows","text":"second function, dodgr_flows_disperse(), uses vector origin () points, aggregates flows disperse throughout network according simple exponential model. place matrix flows required dodgr_flows_aggregate(), dispersal requires equivalent vector densities dispersing origin () points. illustrated following code, using graph previous example.","code":"dens <- rep (1, length (from)) # uniform densities graph_f <- dodgr_flows_disperse (graph, from = from, dens = dens) summary (graph_f$flow) ##      Min.   1st Qu.    Median      Mean   3rd Qu.      Max.  ## 0.000e+00 0.000e+00 7.549e-05 8.658e-03 1.010e-02 1.587e-01"},{"path":"https://UrbanAnalyst.github.io/dodgr/articles/flows.html","id":"merging-directed-flows","dir":"Articles","previous_headings":"","what":"3 Merging directed flows","title":"dodgr flows","text":"Note flows dodgr_flows_aggregate() dodgr_flows_disperse() directed, flow ‘’ ‘B’ necessarily equal flow ‘B’ ‘’. often desirable aggregate flows undirected manner, example visualisations plotting pairs directed flows edge often feasible large graphs. Directed flows can aggregated equivalent undirected flows merge_directed_graph() function: Resultant graphs produced merge_directed_graph() include edges non-zero flows, : resultant graph can readily merged original graph regain original data vertex coordinates graph may used visualise flows dodgr_flowmap() function:","code":"graph_undir <- merge_directed_graph (graph_f) nrow (graph_f) ## [1] 6813 nrow (graph_undir) # the latter is much smaller ## [1] 3069 graph <- graph [graph_undir$edge_id, ] graph$flow <- graph_undir$flow graph_f <- graph_f [graph_f$flow > 0, ] dodgr_flowmap (graph_f, linescale = 5)"},{"path":"https://UrbanAnalyst.github.io/dodgr/articles/flows.html","id":"flows-from-spatial-interaction-models","dir":"Articles","previous_headings":"","what":"4. Flows from spatial interaction models","title":"dodgr flows","text":"additional function, dodgr_flows_si() enables flows aggregated according exponential spatial interaction models. function called just dodgr_flows_aggregate() call demonstrated , without flows matrix specifying strengths flows pair points.  Flows graph notably lower previous one, previous one aggregated flows pairs points attenuation. Spatial interaction models attenuate attraction based far apart two points , well flows along paths points based exponential decay model. documentation function describes several ways attenuation can controlled, easiest via single numeric value. Reducing attenuation gives following result:","code":"graph_f <- dodgr_flows_si (graph, from = from, to = to) graph_undir <- merge_directed_graph (graph_f) graph <- graph [graph_undir$edge_id, ] graph$flow <- graph_undir$flow graph_f <- graph_f [graph_f$flow > 0, ] dodgr_flowmap (graph_f, linescale = 5) graph <- weight_streetnet (hampi, wt_profile = \"foot\") graph_f <- dodgr_flows_si (graph, from = from, to = to, k = 1e6) graph_undir <- merge_directed_graph (graph_f) graph <- graph [graph_undir$edge_id, ] graph$flow <- graph_undir$flow graph_f <- graph_f [graph_f$flow > 0, ] dodgr_flowmap (graph_f, linescale = 5)"},{"path":"https://UrbanAnalyst.github.io/dodgr/articles/iso.html","id":"input-formats","dir":"Articles","previous_headings":"","what":"Input formats","title":"dodgr isochrones, isodists, and isoverts","text":"dodgr_isodists() function accepts arbitrary input, either generic dodgr data.frame (“distance” column), street networks derived applying weight_streetnet() function either sf st objects. Time-based calculations dodgr possible applied street networks dervied st objects, equivalent sf-based objects can provide crude estimates journey times. time-specific functions dodgr_isochrones() dodgr_isoverts() thus accept dodgr street networks derived sc data. following table summarises requirements functions:","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/articles/iso.html","id":"dodgr_isodists","dir":"Articles","previous_headings":"","what":"dodgr_isodists","title":"dodgr isochrones, isodists, and isoverts","text":"dodgr_isodists() function calculates contours equal distance one points origin. function returns case data.frame columns shown 2,573 points defining isodistance contours origin () point, specified distances 200, 500, 1000, 2000 metres. naturally points defining contours longer distances: points defining contours arranged anticlockwise order around point origin, can directly visualised using base graphics functions. easier see using just single point origin:","code":"graph <- weight_streetnet (hampi) from <- sample (graph$from_id, size = 100) dlim <- c (2, 5, 10, 20) * 100 d <- dodgr_isodists (graph, from = from, dlim) dim (d) ## [1] 2573    5 knitr::kable (head (d)) table (d$dlim) ##  ##  200  500 1000 2000  ##  406  578  716  873 set.seed (1) from <- sample (graph$from_id, size = 1) dlim <- c (2, 5, 10, 20) * 100 d <- dodgr_isodists (graph, from = from, dlim) cols <- terrain.colors (length (dlim) + 2) # + 2 to avoid light colours at end of scale. index <- which (d$dlim == max (d$dlim)) # plot max contour first plot (     d$x [index], d$y [index], \"l\",     col = cols [1],     xlab = \"longitude\", ylab = \"latitude\" ) for (i in seq (dlim) [-1]) {     index <- which (d$dlim == rev (dlim) [i])     lines (d$x [index], d$y [index], col = cols [i], lwd = i + 1) }"},{"path":"https://UrbanAnalyst.github.io/dodgr/articles/iso.html","id":"the-concavity-parameter","dir":"Articles","previous_headings":"dodgr_isodists","what":"The concavity parameter","title":"dodgr isochrones, isodists, and isoverts","text":"default contours convex hulls. dodgr_isodists() dodgr_isochrones() functions include additional concavity parameter return generate concave isodistance isochrone polygons, defaulting value 0 concavity. Changing value can generate concave contours like following results:  calculation isodists isochrone values cached, different values concavity parameter can trialled without needing re-calculate underlying values: concavity parameter default value 0 strictly convex polygons. Values closer 1 generate concave polygons. following code demonstrates effect increasing values parameter.","code":"set.seed (1) from <- sample (graph$from_id, size = 1) dlim <- c (2, 5, 10, 20) * 100 d <- dodgr_isodists (graph, from = from, dlim, concavity = 0.5) cols <- terrain.colors (length (dlim)) index <- which (d$dlim == max (d$dlim)) plot (     d$x [index], d$y [index], \"l\",     col = cols [1],     xlab = \"longitude\", ylab = \"latitude\" ) for (i in seq (dlim) [-1]) {     index <- which (d$dlim == rev (dlim) [i])     lines (d$x [index], d$y [index], col = cols [i], lwd = i + 1) } set.seed (2) from <- sample (graph$from_id, size = 1) dlim <- c (2, 5, 10, 20) * 100 system.time ( # Initial call calculates distances to all points:     d <- dodgr_isodists (graph, from = from, dlim, concavity = 0.5) ) ##    user  system elapsed  ##   0.160   0.001   0.161 system.time ( # Subsequent call uses cached values:     d <- dodgr_isodists (graph, from = from, dlim, concavity = 0.75) ) ##    user  system elapsed  ##   0.021   0.000   0.021 set.seed (5) from <- sample (graph$from_id, size = 1) dlim <- 2000 concavity <- 0:4 / 4 d <- lapply (concavity, function (i) dodgr_isodists (graph, from = from, dlim, concavity = i)) cols <- terrain.colors (length (d) + 2) plot (     d [[1]]$x, d [[1]]$y,     type = \"l\",     col = cols [1], lwd = 5,     xlab = \"longitude\", ylab = \"latitude\" ) for (i in seq_along (d) [-1]) {     lines (         d [[i]]$x, d [[i]]$y,         col = cols [i], lwd = 6 - i, lty = i     ) } v <- dodgr_vertices (graph) v_from <- v [match (from, v$id), ] points (v_from [, c (\"x\", \"y\")], pch = 19, col = \"red\", cex = 2)"},{"path":"https://UrbanAnalyst.github.io/dodgr/articles/iso.html","id":"dodgr_isochrones","dir":"Articles","previous_headings":"","what":"dodgr_isochrones","title":"dodgr isochrones, isodists, and isoverts","text":"dodgr_isochrones() works just like dodgr_isodists() except can applied street networks generated silicate (SC) format data. results differ equivalent distance results column named “tlim” (“time”) instead “dlim” (“distance”). concavity parameter functions exactly way described .","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/articles/iso.html","id":"dodgr_isoverts","dir":"Articles","previous_headings":"","what":"dodgr_isoverts","title":"dodgr isochrones, isodists, and isoverts","text":"dodgr_isodists() dodgr_isochrones() functions work estimating distances times specified origin points points maximum specified values dlim tlim. second stage generates convex concave hulls around points, result containing ordered sequence points tracing contours around hulls. dodgr_isoverts() function generates full underlying set points without applying hull-tracing routines. resultant points may used, example, apply custom hull-tracing routine, perform statistical analyses full points enclosed within specified values dlim tlim. object returned function identical demonstrated , column named “dlim” dlim parameter specified, “tlim” tlim parameter specified. data.frame returned dodgr_isoverts() always contain data, rows, equivalent results dodgr_isodists() dodgr_isochrones(). rows data.frame returned dodgr_isoverts() ordered increasing dlim tlim values, rows given value parameters arbitrary order. successively higher value either dlim tlim includes points denoted lower values. example, values contained within dlim = 200 specified value dlim plus rows values dlim < 200. following code demonstrates typical sizes results dodgr_isodists() dodgr_isoverts() functions:","code":"dat <- dodgr_streetnet_sc (\"hampi india\") graph <- weight_streetnet (dat, wt_profile = \"foot\") set.seed (1) from <- sample (graph$.vx0, size = 1) dlim <- c (2, 5, 10, 20) * 100 nrow (dodgr_isodists (graph, from = from, dlim)) ## [1] 34 nrow (dodgr_isoverts (graph, from = from, dlim)) ## [1] 145"},{"path":"https://UrbanAnalyst.github.io/dodgr/articles/times.html","id":"street-networks-and-time-based-routing","dir":"Articles","previous_headings":"","what":"1 Street Networks and Time-Based Routing","title":"Street networks and time-based routing","text":"vignette describes use dodgr package routing street networks, specifically Open Street Map (OSM) networks extracted osmdata package, via dodgr functions dodgr_streetnet() dodgr_streetnet_sc(). functions use osmdata package package extract networks Open Street Map, former returning data Simple Features (sf) format, latter Silicate (sc) format. latter format enables detailed weighting, notably including effects turning angles elevation, described . vignette describes different approaches weighting street networks routing based either distances (shortest paths) times (fastest paths). start briefly describing Silicate (sc) format data returned dodgr_streetnet_sc(), including ability incorporate elevation data, describing use data different kinds routing.","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/articles/times.html","id":"silicate-data-and-the-dodgr_streetnet_sc-function","dir":"Articles","previous_headings":"","what":"2. Silicate data and the dodgr_streetnet_sc() function","title":"Street networks and time-based routing","text":"Silicate (sc) new format spatial data. Unlike almost previous formats available R representing processing spatial data, attempt wrangle complex, multidimensional data single, flat table, Silicate (sc) format multi-tabular. simplest form, consists three tables vertices, edges, objects. vertices points, edges binary relationships connections , objects high-order relationships assemblages edges. new osmdata function, osmdata_sc() extracts OSM data Silicate (sc) format, returns seven tables plus additional table meta-data. dodgr functions may directly used without understanding format data, wishing know, tables : nodes, containing OSM key-value data nodes vertices; relation_members containing membership information OSM relations; relation_properties, containing key-value data OSM relations; object, containing key-value data OSM ways; object_link_edge, connecting object members constituent edges; edge, simple table vertex pairs forming edge; vertex, containing coordinates ID values OSM node, along elevation data provided. Elevation data used time-based routing, particularly important modelling pedestrian bicycle transport. may readily incorporated Silicate (sc) format data new osmdata function, osm_elevation(). function requires locally-stored GeoTIFF-formatted elevation data file downloaded Consortium Spatial Information, source. data may appended calling osm_elevation(), specifying name file. time-based routing possible sf format data, currently possible incorporate elevation data data.","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/articles/times.html","id":"the-weight_streetnet-function","dir":"Articles","previous_headings":"","what":"3. The weight_streetnet() function","title":"Street networks and time-based routing","text":"dodgr package represents networks, including street networks, flat, tabular form row represents network edge. Spatial data derived OSM, either explicitly osmdata package, dodgr helper functions, dodgr_streetnet() sf dodgr_streetnet_sc() sc format data, may directly submitted dodgr function, weight_streetnet(). two important parameters function : wt_profile, character string generally specifying mode transport (generally one “bicycle”, “foot”, “goods”, “hgv”, “horse”, “moped”, “motorcar”, “motorcycle”, “psv”, “wheelchair”); turn_penalty, specifying whether edge times include delays associated turning across oncoming traffic, whether turn restrictions obeyed. first options described following sub-section. second option effect sf data, particularly important sc format data, enables estimation temporal delays associated turning across oncoming traffic, implements restrictions turns specific modes transport specified Open Street Map. (Turn penalty restrictions given final column “penalties” table weighting_profiles data.) Calculation turn penalties achieved fundamentally modifying resultant graph depicted Fig. 1.  Figure 1 depicts right-angled crossing, straight arrows showing single directed edge crossing (solid black line), three directed edges going (solid grey lines). Turning across oncoming traffic generally takes time (precise values detailed following section), turning left (→BA\\rightarrow B Fig. 1) always different turning right (→CA\\rightarrow C). reflect differences, graphs weighted account turning penalties adding three “compound” edges directly connecting AA end points BB, CC, DD, including additional time penalties turning across oncoming traffic. (latter naturally dependent side road traffic travels, weight_streetnet() includes additional left_side parameter specify whether traffic travels left side street.) compound edges , however, simply replace previous edges, routing may still need begin end junction node, OO. edge →OA\\rightarrow O thus retained OO may used destination routing, OO case longer connects outgoing edges. OO may also used starting node routing, edges O→BO\\rightarrow B, O→CO\\rightarrow C, O→\\rightarrow D must also retained. dodgr works uniquely labelling nodes edges, entire situation depicted Fig. 1 achieved replacing OO two new nodes labelled O_startO\\_start O_endO\\_end, end result replacing former four directed edges following seven edges: →O_endA\\rightarrow O\\_end (original black edge, O_endO\\_end longer connects node); O_start→BO\\_start\\rightarrow B (original grey edges, nodes connect O_startO\\_start); O_start→CO\\_start\\rightarrow C (…); O_start→\\_start\\rightarrow D (…); →BA\\rightarrow B (new compound edge); →CA\\rightarrow C (…); →DA\\rightarrow D (…); Weighting time-based routing thus introduces new “compound” edges, also requires re-labelling junction vertices, appending either “_start” “_end”. Recommended practice routing cases select routing vertices (origins destinations) standard weighted graph (, one generated turn_penalty = FALSE), modify routing vertices illustrated following example: time-weighted graph additional compound edges used reflect penalty turning across traffic. Let’s now presume want calculate distances number randomly-selected street junctions. junctions may readily extracted dodgr_contract_graph() function, reduces graph junction vertices . junction vertices graph_t re-labelled described separate incoming outgoing edges (appending _start _end vertex names), may used routing. Instead, routing points taken contracted version original graph. can submitted dodgr functions along graph turn penalties, matched corresponding nodes appended _start fromvertices _end vertices. usual, generally quicker first contract graph prior routing. Contracting graph reduced size almost 80%, translating considerably faster routing queries. resultant graph, along routing points, may passed dodgr routing functions, dodgr_distances(), dodgr_paths(), even dodgr_flows_aggregate(), well -new function detailed following section, dodgr_times().","code":"dat_sc <- dodgr_streetnet_sc (\"ogbomosho nigeria\") graph <- weight_streetnet (dat_sc, wt_profile = \"bicycle\") graph_t <- weight_streetnet (dat_sc, wt_profile = \"bicycle\", turn_penalty = TRUE) nrow (graph) nrow (graph_t) ## [1] 164168 173160 graphc <- dodgr_contract_graph (graph) # not graph_t! v <- dodgr_vertices (graphc) n <- 100 # number of desired vertices from <- sample (v$id, size = n) to <- sample (v$id, size = n) graph_tc <- dodgr_contract_graph (graph_t) nrow (graph_tc) nrow (graph_t) ## [1]  35808 176160"},{"path":"https://UrbanAnalyst.github.io/dodgr/articles/times.html","id":"weighting-profiles-and-the-write_dodgr_wt_profile-function","dir":"Articles","previous_headings":"3. The weight_streetnet() function","what":"3.1 Weighting profiles and the write_dodgr_wt_profile function","title":"Street networks and time-based routing","text":"demonstrated , usage weight_streetnet() function generally simple specifying mode transport network weighted. may nevertheless desirable explicitly determine individual aspects weighting profile (time penalties turning angles explored ). weighting profiles contained internal data, dodgr::weighting_profiles, contain following data, brevity showing “bicycle” mode: main weighting_profiles$weighting_profiles table contains value column used determine preferential weightings particular kinds ways designated mode transport, maximum 1.0 preferable ways 0.0 ways untraversable mode transport, along additional column specifying maximum speeds kilometres per hour. Actual maximum speeds may reduced changes surface, specified second table (surface_speeds), final table contains time penalties seconds traffic lights turn penalties. Values table may edited first creating local, json-formatted version function, write_dodgr_wt_profile(), editing values desired, specifying location json file containing modified data additional argument weight_streetnet() wt_profile_file.","code":"lapply (dodgr::weighting_profiles, function (i) i [i$name == \"bicycle\", ]) ## $weighting_profiles ##       name            way value max_speed ## 67 bicycle       motorway  0.00        NA ## 68 bicycle          trunk  0.30        NA ## 69 bicycle        primary  0.70        15 ## 70 bicycle      secondary  0.80        15 ## 71 bicycle       tertiary  0.90        15 ## 72 bicycle   unclassified  0.90        15 ## 73 bicycle    residential  0.90        15 ## 74 bicycle        service  0.90        15 ## 75 bicycle          track  0.90        12 ## 76 bicycle       cycleway  1.00        15 ## 77 bicycle           path  0.90        12 ## 78 bicycle          steps  0.50         4 ## 79 bicycle          ferry  0.20        15 ## 80 bicycle  living_street  0.95        15 ## 81 bicycle      bridleway  0.70         8 ## 82 bicycle        footway  0.90         4 ## 83 bicycle     pedestrian  0.80         4 ## 84 bicycle  motorway_link  0.00        NA ## 85 bicycle     trunk_link  0.30        NA ## 86 bicycle   primary_link  0.70        15 ## 87 bicycle secondary_link  0.80        15 ## 88 bicycle  tertiary_link  0.90        15 ##  ## $surface_speeds ##       name     key                 value max_speed ## 24 bicycle surface cobblestone:flattened        10 ## 25 bicycle surface         paving_stones        10 ## 26 bicycle surface             compacted        10 ## 27 bicycle surface           cobblestone         6 ## 28 bicycle surface               unpaved         6 ## 29 bicycle surface           fine_gravel         6 ## 30 bicycle surface                gravel         6 ## 31 bicycle surface           pebblestone         6 ## 32 bicycle surface                ground         6 ## 33 bicycle surface                  dirt         6 ## 34 bicycle surface                 earth         6 ## 35 bicycle surface                 grass         6 ## 36 bicycle surface                   mud         3 ## 37 bicycle surface                  sand         3 ## 38 bicycle surface                  sett        10 ##  ## $penalties ##      name traffic_lights turn restrictions ## 4 bicycle              2    6        FALSE"},{"path":"https://UrbanAnalyst.github.io/dodgr/articles/times.html","id":"time-based-routing-and-the-dodgr_times-function","dir":"Articles","previous_headings":"","what":"4. Time-based routing and the dodgr_times() function","title":"Street networks and time-based routing","text":"default, dodgr_distances() standard routing functions (paths, flows_) distance-based, meaning routing along paths shortest distances. contrast, time-based routing calculates paths shortest times; words, fastest rather shortest paths. Distances may nevertheless calculated along fastest paths, shortest = FALSE parameter. function still returns distances (metres), calculated along fastest paths. example:  average distance two (metres) : plot reveals shortest distances indeed somewhat shorter distances along fastest paths, also fastest paths actually shorter shortest paths: dodgr indeed routing engines attempt maximally reconcile differences fastest shortest routes, nevertheless remain important discrepancies. Foremost among , primary reason fastest routes may fact shorter shortest routes, fastest routes allocate preferences different kinds way based value column weighting_profiles$weighting_profiles table illustrated , actual maximum speed given edge, may combination maximum speeds specified OSM , maximum speeds weighting_profiles$weighting_profiles table, values specific given surface. result unique combination maximum speeds along network may lead fastest routes preferentially directed along path actually shorter direct shortest path calculated independent maximum speed values. discrepancies important understanding differences routes times calculated along shortest versus fastest paths. times can calculated (seconds) dodgr_times() function:  , times along fastest paths generally less times along shortest paths, although exceptions: results demonstrate combination dodgr_distances() dodgr_times() functions enable calculation distances times along shortest fastest paths.","code":"graph <- weight_streetnet (hampi, wt_profile = \"foot\") n <- 100 # number of sample routing vertices set.seed (1) from <- sample (graph$from_id, size = n) to <- sample (graph$from_id, size = n) d_dist <- dodgr_dists (graph, from = from, to = to, shortest = TRUE) # default d_time <- dodgr_dists (graph, from = from, to = to, shortest = FALSE) # fastest paths plot (d_dist / 1000, d_time / 1000,     col = \"orange\",     xlab = \"distances along shortest paths (km)\",     ylab = \"distances along fastest paths (km)\" ) lines (0:100, 0:100, col = \"red\", lty = 2) mean (abs (d_time - d_dist), na.rm = TRUE) ## [1] 25.72338 index <- which (!is.na (d_time) & !is.na (d_dist)) length (which (d_time [index] < d_dist [index])) / length (index) ## [1] 0.0257905 t_dist <- dodgr_times (graph, from = from, to = to, shortest = TRUE) # default t_time <- dodgr_times (graph, from = from, to = to, shortest = FALSE) # fastest paths plot (t_dist / 3600, t_time / 3600,     col = \"orange\",     xlab = \"times along shortest paths (hours)\",     ylab = \"times along fastest paths (hours)\" ) lines (0:100, 0:100, col = \"red\", lty = 2) mean (abs (t_time - t_dist), na.rm = TRUE) ## [1] 75.50527 index <- which (!is.na (t_time) & !is.na (t_dist)) length (which (t_dist [index] < t_time [index])) / length (index) ## [1] 0.0063593"},{"path":"https://UrbanAnalyst.github.io/dodgr/articles/times.html","id":"time-based-paths-and-flow-aggregation","dir":"Articles","previous_headings":"4. Time-based routing and the dodgr_times() function","what":"4.1 Time-based paths and flow aggregation","title":"Street networks and time-based routing","text":"dodgr_times() works simply swapping columns graph, distance becomes time, weighted distance becomes weighted time. dodgr routing functions (dodgr_paths(), dodgr_flows_aggregate(), dodgr_flows_disperse()) explicit time-based equivalents. Instead, time-based routing can implemented simply replacing weighted distance column (d_weighted) weighted time column (time_weighted): routes automatically calculated along fastest rather shortest routes.","code":"graph$d_weighted <- graph$time_weighted"},{"path":"https://UrbanAnalyst.github.io/dodgr/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Mark Padgham. Author, maintainer. Andreas Petutschnig. Author. David Cooley. Author. Robin Lovelace. Contributor. Andrew Smith. Contributor. Malcolm Morgan. Contributor. Andrea Gilardi. Contributor. Eduardo Leoni. Contributor. Shane Saunders. Copyright holder.           Original author included code priority heaps Stanislaw Adaszewski. Copyright holder.           author include concaveman-cpp code","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Mark Padgham (2019) dodgr: R package network flow aggregation Transport Findings, 2(14). URL https://doi.org/10.32866/6945","code":"@Article{,   journal = {Transport Findings},   doi = {10.32866/6945},   publisher = {Network Design Lab},   title = {dodgr: An R package for network flow aggregation},   author = {{Mark Padgham}},   year = {2019},   month = {2}, }"},{"path":"https://UrbanAnalyst.github.io/dodgr/index.html","id":"dodgr-distances-on-directed-graphs-in-r","dir":"","previous_headings":"","what":"Distances on Directed Graphs","title":"Distances on Directed Graphs","text":"dodgr R package efficient calculation many--many pairwise distances dual-weighted directed graphs, aggregation flows throughout networks, highly realistic routing street networks (time-based routing considering incline, turn-angles, surface quality, everything). Note dodgr algorithms implement parallel computation RcppParallel library, default use maximal number available cores threads. wish dodgrto use available threads, please reduce number manually first specifying value via","code":"RcppParallel::setThreadOptions (numThreads = 1L) # or desired number"},{"path":"https://UrbanAnalyst.github.io/dodgr/index.html","id":"whats-so-special","dir":"","previous_headings":"","what":"What’s so special?","title":"Distances on Directed Graphs","text":"Four aspects. First, packages exist calculating distances directed graphs, notably igraph, even otherwise fabulous package (readily) permit analysis dual-weighted graphs. Dual-weighted graphs two sets weights edge, routing can evaluated one set weights, distances can calculated . canonical example street network, weighted distances assigned depending mode transport (example, weighted distances pedestrians multi-lane vehicular roads longer equivalent distances along isolated walking paths), yet desired output remains direct, unweighted distances. Accurate calculation distances street networks requires dual-weighted representation. R, dodgr currently package offers functionality (without excessive data wrangling). Second, igraph almost routing packages primarily designed one--one routing, dodgr specifically designed many--many routing, generally outperform equivalent packages large routing tasks. Third, dodgr goes beyond functionality comparable packages including routines aggregate flows throughout network, specifying origins, destinations, flow densities pair points. Alternatively, flows can aggregated according network dispersal model set origin points associated densities, user-specified dispersal model. Fourth finally, dodgr implements highly realistic fully-customisable profiles routing street networks various modes transport, using either distance- time-based routing. Routing can include factors waiting times traffic lights, delays turning across oncoming traffic, access restrictions, effects elevation cyclists pedestrians. See dedicated vignette street networks time-based routing detail.","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Distances on Directed Graphs","text":"can install latest stable version dodgr CRAN : Alternatively, current development versions can installed using following options: load ","code":"install.packages (\"dodgr\") # current CRAN version # install.packages(\"remotes\") remotes::install_git (\"https://git.sr.ht/~mpadge/dodgr\") remotes::install_git (\"https://codeberg.org/UrbanAnalyst/dodgr\") remotes::install_bitbucket (\"UrbanAnalyst/dodgr\") remotes::install_gitlab (\"UrbanAnalyst/dodgr\") remotes::install_github (\"UrbanAnalyst/dodgr\") library (dodgr) packageVersion (\"dodgr\") #> [1] '0.4.2'"},{"path":"https://UrbanAnalyst.github.io/dodgr/index.html","id":"important-note","dir":"","previous_headings":"","what":"Important Note","title":"Distances on Directed Graphs","text":"dodgr works arbitrary networks, also includes numerous functions explicitly intended applied geodesic coordinates, identified whenever input data columns labelled “longitude” “latitude”, similar. Coordinates data must EPSG:4326 (WGS84) coordinate system. dodgr treats coordinates numbers , user ensure appropriate transformation WGS84 coordinates prior submitting data dodgr functions.","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/index.html","id":"usage-sample-data-and-dodgr-networks","dir":"","previous_headings":"","what":"Usage: Sample Data and dodgr networks","title":"Distances on Directed Graphs","text":"illustrate functionality, package includes example data set containing Open Street Map network Hampi, India (primarily pedestrian village middle large World Heritage zone). data Simple Features (sf) format, collection LINESTRING objects. dodgr represents networks simple rectangular graph, row representing edge segment two points vertices. sf-format objects can converted equivalent dodgr representations weight_streetnet() function: sf-format network contained 236 LINESTRING objects, weight_streetnet() function decomposing 6,813 distinct edges, indicating sf representation around 29 edges segments LINESTRING object. dodgr network looks like : geom_num column maps directly onto sequence LINESTRING objects within sf-formatted data. highway column taken directly Open Street Map, denotes kind “highway” represented edge. component column integer value describing connected components network edge belongs (1 always largest component; 2 second largest; ). Note d_weighted values often greater geometric distances, d. example shown, service highways ideal pedestrians, weighted distances slightly greater actual distances. Compare : \"path\" offers ideal walking conditions, weighted distances equal actual distances.","code":"class (hampi) #> [1] \"sf\"         \"data.frame\" dim (hampi) #> [1] 236  15 graph <- weight_streetnet (hampi, wt_profile = \"foot\") class (graph) #> [1] \"dodgr_streetnet\" \"data.frame\" dim (graph) #> [1] 6813   15 head (graph) head (graph [graph$highway == \"path\", ])"},{"path":"https://UrbanAnalyst.github.io/dodgr/index.html","id":"usage-distances-and-times","dir":"","previous_headings":"","what":"Usage: Distances and Times","title":"Distances on Directed Graphs","text":"many--many nature dodgr means function calculate distances, dodgr_distances() , street networks, times, dodgr_times(), accepts two vectors matrices routing points inputs (describing origins destinations), returns corresponding matrix pairwise distances. input graph columns distances weighted distances, /times weighted times, weighted versions used determine effectively shortest fastest routes network, actual distances times summed along routes calculate final values. course also possible calculate distances along fastest routes, times along shortest routes, combination thereof, detailed package vignette street networks time-based routing. Routing points can, example, randomly selected vertices graph. vertices can turn extracted dodgr_vertices() function: OSM data extracted osmdata package (, equivalently, via dodgr::dodgr_streetnet() function), object (vertices, ways, high-level relations objects) assigned unique identifying number. retained osmdata dodgr, way_id column graph, id column vertices. Random vertices may generated case selecting id values: Alternatively, points may specified matrices geographic coordinates: case, random points mapped nearest points street network. may, course, map points onto minor, disconnected components graph. can controlled either reducing graph ’s largest connected component : explicitly using match_points_to_verts() function option connected = TRUE: function returns index result dodgr_vertices, points use routing must extracted follows:","code":"v <- dodgr_vertices (graph) head (v) from <- sample (v$id, size = 20) to <- sample (v$id, size = 50) d <- dodgr_dists (graph = graph, from = from, to = to) dim (d) #> [1] 20 50 from_x <- min (graph$from_lon) + runif (20) * diff (range (graph$from_lon)) from_y <- min (graph$from_lat) + runif (20) * diff (range (graph$from_lat)) to_x <- min (graph$from_lon) + runif (50) * diff (range (graph$from_lon)) to_y <- min (graph$from_lat) + runif (50) * diff (range (graph$from_lat)) d <- dodgr_dists (graph = graph, from = cbind (from_x, from_y), to = cbind (to_x, to_y)) graph <- graph [graph$component == 1, ] nrow (graph) from <- match_points_to_verts (v, cbind (from_x, from_y), connected = TRUE) to <- match_points_to_verts (v, cbind (to_x, to_y), connected = TRUE) from <- v$id [from] # or from <- v [from, c (\"x\", \"y\")] to <- v$id [to] d <- dodgr_dists (graph = graph, from = from, to = to)"},{"path":"https://UrbanAnalyst.github.io/dodgr/index.html","id":"usage-flow-aggregation","dir":"","previous_headings":"","what":"Usage: Flow Aggregation","title":"Distances on Directed Graphs","text":"Flow aggregation refers procedure routing along multiple ways according specified densities flow defined origin destination points, aggregating flows along edge network. procedure functionally similar procedure distances, addition matrix specifying pairwise flow densities input set origin () destination () points. following example illustrates use random “flow matrix”: result simply input graph additional column quantifying aggregate flows along edge: additional flow aggregation function can applied cases densities origin points known, movement throughout graph dispersive:","code":"flows <- array (runif (length (from) * length (to)), dim = c (length (from), length (to))) length (from) #> [1] 20 length (to) #> [1] 50 dim (flows) #> [1] 20 50 f <- dodgr_flows_aggregate (graph = graph, from = from, to = to, flows = flows) head (f) f <- dodgr_flows_disperse (graph = graph, from = from, dens = runif (length (from)))"},{"path":"https://UrbanAnalyst.github.io/dodgr/index.html","id":"further-detail","dir":"","previous_headings":"","what":"Further detail","title":"Distances on Directed Graphs","text":"detail, see main package vignette, second vignette street networks time-based routing","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/index.html","id":"contributors","dir":"","previous_headings":"","what":"Contributors","title":"Distances on Directed Graphs","text":"contributions project gratefully acknowledged using allcontributors package following allcontributors specification. Contributions kind welcome!","code":""},{"path":[]},{"path":[]},{"path":[]},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/add_nodes_to_graph.html","id":null,"dir":"Reference","previous_headings":"","what":"Insert new nodes into a graph, breaking edges at point of nearest intersection. — add_nodes_to_graph","title":"Insert new nodes into a graph, breaking edges at point of nearest intersection. — add_nodes_to_graph","text":"Note routine presumes graphs dodgr_streetnet object, geographical coordinates.","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/add_nodes_to_graph.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Insert new nodes into a graph, breaking edges at point of nearest intersection. — add_nodes_to_graph","text":"","code":"add_nodes_to_graph(graph, xy, dist_tol = 0.000001, intersections_only = FALSE)"},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/add_nodes_to_graph.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Insert new nodes into a graph, breaking edges at point of nearest intersection. — add_nodes_to_graph","text":"graph dodgr graph spatial coordinates, dodgr_streetnet object. xy coordinates points matched vertices, either matrix sf-formatted data.frame. dist_tol insert new nodes existing nodes distance, expressed units distance column graph. intersections_only FALSE","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/add_nodes_to_graph.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Insert new nodes into a graph, breaking edges at point of nearest intersection. — add_nodes_to_graph","text":"modified version graph, additional edges formed breaking previous edges nearest perpendicular intersections points, xy.","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/add_nodes_to_graph.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Insert new nodes into a graph, breaking edges at point of nearest intersection. — add_nodes_to_graph","text":"inserts new nodes extending lines input point edge closest point perpendicular intersection. edge split point intersection, creating two new edges (four directed edges). intersections_only = FALSE (default), additional edges inserted intersection points input points. intersections_only = TRUE, nodes added splitting graph edges points nearest perpendicular intersection, without adding additional edges actual input points. former case, properties new edges, distance time weightings, inherited edges intersected, may need manually modified calling function.","code":""},{"path":[]},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/add_nodes_to_graph.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Insert new nodes into a graph, breaking edges at point of nearest intersection. — add_nodes_to_graph","text":"","code":"graph <- weight_streetnet (hampi, wt_profile = \"foot\") dim (graph) #> [1] 6813   15  verts <- dodgr_vertices (graph) set.seed (2) npts <- 10 xy <- data.frame (     x = min (verts$x) + runif (npts) * diff (range (verts$x)),     y = min (verts$y) + runif (npts) * diff (range (verts$y)) )  graph <- add_nodes_to_graph (graph, xy) dim (graph) # more edges than original #> [1] 6863   15"},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/clear_dodgr_cache.html","id":null,"dir":"Reference","previous_headings":"","what":"Remove cached versions of dodgr graphs. — clear_dodgr_cache","title":"Remove cached versions of dodgr graphs. — clear_dodgr_cache","text":"function generally needed, except graph structure directly modified dodgr functions; example modifying edge weights distances. Graphs cached based vector edge IDs, manual changes attributes necessarily translated changes dodgr output unless cached versions cleared using function. See https://github.com/UrbanAnalyst/dodgr/wiki/Caching--streetnets--contracted-graphs details caching process.","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/clear_dodgr_cache.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Remove cached versions of dodgr graphs. — clear_dodgr_cache","text":"","code":"clear_dodgr_cache()"},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/clear_dodgr_cache.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Remove cached versions of dodgr graphs. — clear_dodgr_cache","text":"Nothing; function silently clears cached objects","code":""},{"path":[]},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/compare_heaps.html","id":null,"dir":"Reference","previous_headings":"","what":"Compare timings of different sort heaps for a given input graph. — compare_heaps","title":"Compare timings of different sort heaps for a given input graph. — compare_heaps","text":"Perform timing comparison different kinds heaps well equivalent routines igraph package. , random sub-graph containing defined number vertices first selected. Alternatively, random sub-graph can pre-generated dodgr_sample function passed directly.","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/compare_heaps.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compare timings of different sort heaps for a given input graph. — compare_heaps","text":"","code":"compare_heaps(graph, nverts = 100, replications = 2)"},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/compare_heaps.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compare timings of different sort heaps for a given input graph. — compare_heaps","text":"graph data.frame object representing network graph (sub-sample selected dodgr_sample) nverts Number vertices used generate random sub-graph. non-numeric value given, whole graph used. replications Number replications used comparison","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/compare_heaps.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compare timings of different sort heaps for a given input graph. — compare_heaps","text":"Result bench::mark comparison.","code":""},{"path":[]},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/compare_heaps.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compare timings of different sort heaps for a given input graph. — compare_heaps","text":"","code":"graph <- weight_streetnet (hampi) if (FALSE) { # \\dontrun{ compare_heaps (graph, nverts = 1000, replications = 1) } # }"},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr.html","id":null,"dir":"Reference","previous_headings":"","what":"Distances On Directed GRaphs (","title":"Distances On Directed GRaphs (","text":"Distances dual-weighted directed graphs using priority-queue shortest paths. Weighted directed graphs weights B may differ B . Dual-weighted directed graphs two sets weights. canonical example street network used routing routes calculated weighting distances according type way mode transport, yet lengths routes must calculated direct distances.","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr.html","id":"the-main-function","dir":"Reference","previous_headings":"","what":"The Main Function","title":"Distances On Directed GRaphs (","text":"dodgr_dists(): Calculate pair-wise distances specified pairs points graph.","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr.html","id":"functions-to-obtain-graphs","dir":"Reference","previous_headings":"","what":"Functions to Obtain Graphs","title":"Distances On Directed GRaphs (","text":"dodgr_streetnet(): Extract street network Simple Features (sf) form. weight_streetnet(): Convert sf-formatted street network dodgr graph applying specified weights edges.","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr.html","id":"functions-to-modify-graphs","dir":"Reference","previous_headings":"","what":"Functions to Modify Graphs","title":"Distances On Directed GRaphs (","text":"dodgr_components(): Number graph edges according presence distinct connected components. dodgr_contract_graph(): Contract graph removing redundant edges.","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr.html","id":"miscellaneous-functions","dir":"Reference","previous_headings":"","what":"Miscellaneous Functions","title":"Distances On Directed GRaphs (","text":"dodgr_sample(): Randomly sample graph, returning single connected component defined number vertices. dodgr_vertices(): Extract vertices graph. compare_heaps(): Compare performance different priority queue heap structures given type graph.","code":""},{"path":[]},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Distances On Directed GRaphs (","text":"Maintainer: Mark Padgham mark.padgham@email.com Authors: Andreas Petutschnig David Cooley contributors: Robin Lovelace [contributor] Andrew Smith [contributor] Malcolm Morgan [contributor] Andrea Gilardi (ORCID) [contributor] Eduardo Leoni (ORCID) [contributor] Shane Saunders (Original author included code priority heaps) [copyright holder] Stanislaw Adaszewski (author include concaveman-cpp code) [copyright holder]","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_cache_off.html","id":null,"dir":"Reference","previous_headings":"","what":"Turn off all dodgr caching in current session. — dodgr_cache_off","title":"Turn off all dodgr caching in current session. — dodgr_cache_off","text":"function useful speed paramount, graph contraction needed. Caching can switched back dodgr_cache_on.","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_cache_off.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Turn off all dodgr caching in current session. — dodgr_cache_off","text":"","code":"dodgr_cache_off()"},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_cache_off.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Turn off all dodgr caching in current session. — dodgr_cache_off","text":"Nothing; function invisibly returns TRUE successful.","code":""},{"path":[]},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_cache_on.html","id":null,"dir":"Reference","previous_headings":"","what":"Turn on all dodgr caching in current session. — dodgr_cache_on","title":"Turn on all dodgr caching in current session. — dodgr_cache_on","text":"effect caching turned dodgr_cache_off.","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_cache_on.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Turn on all dodgr caching in current session. — dodgr_cache_on","text":"","code":"dodgr_cache_on()"},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_cache_on.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Turn on all dodgr caching in current session. — dodgr_cache_on","text":"Nothing; function invisibly returns TRUE successful.","code":""},{"path":[]},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_centrality.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate betweenness centrality for a 'dodgr' network. — dodgr_centrality","title":"Calculate betweenness centrality for a 'dodgr' network. — dodgr_centrality","text":"Centrality can calculated either vertex- edge-based form.","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_centrality.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate betweenness centrality for a 'dodgr' network. — dodgr_centrality","text":"","code":"dodgr_centrality(   graph,   contract = TRUE,   edges = TRUE,   column = \"d_weighted\",   vert_wts = NULL,   dist_threshold = NULL,   heap = \"BHeap\",   check_graph = TRUE )"},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_centrality.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate betweenness centrality for a 'dodgr' network. — dodgr_centrality","text":"graph 'data.frame' equivalent object representing network graph (see Details) contract 'TRUE', centrality calculated contracted graph mapping back original full graph. Note street networks, particular obtained osmdata package, vertex placement effectively arbitrary except junctions; centrality graphs calculated latter points, thus 'contract' always 'TRUE'. edges 'TRUE', centrality calculated graph edges, returning input 'graph' additional 'centrality' column; otherwise centrality calculated vertices, returning equivalent 'dodgr_vertices(graph)', additional vertex-based 'centrality' column. column Column graph defining edge properties used calculate centrality (see Note). vert_wts Optional vector length equal number vertices (nrow(dodgr_vertices(graph))), enable centrality calculated weighted form, centrality measured vertex weighted specified amount. dist_threshold 'NULL', calculate centrality point specified threshold. Setting values result approximate estimates centrality, yet considerable gains computational efficiency. sufficiently large values, approximations accurate within constant multiplier. Appropriate values can established via estimate_centrality_threshold function. heap Type heap use priority queue. Options include Fibonacci Heap (default; 'FHeap'), Binary Heap ('BHeap'), Trinomial Heap ('TriHeap'), Extended Trinomial Heap ('TriHeapExt', 2-3 Heap ('Heap23'). check_graph TRUE, graph first checked duplicate edges, can cause incorrect centrality calculations. duplicate edges detected interactive session, prompt ask whether want proceed rectify edges first. value may set FALSE skip check interactive prompt.","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_centrality.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate betweenness centrality for a 'dodgr' network. — dodgr_centrality","text":"Modified version graph additional 'centrality' column added.","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_centrality.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Calculate betweenness centrality for a 'dodgr' network. — dodgr_centrality","text":"column parameter default d_weighted, meaning centrality calculated routing according weighted distances. possible values parameter d unweighted distances time unweighted time-based routing time_weighted weighted time-based routing Centrality calculated default using parallel computation maximal number available cores threads. number can reduced specifying value via RcppParallel::setThreadOptions (numThreads = <desired_number>).","code":""},{"path":[]},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_centrality.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate betweenness centrality for a 'dodgr' network. — dodgr_centrality","text":"","code":"if (FALSE) { # \\dontrun{ graph_full <- weight_streetnet (hampi) graph <- dodgr_contract_graph (graph_full) graph <- dodgr_centrality (graph) # 'graph' is then the contracted graph with an additional 'centrality' column # Same calculation via 'igraph': igr <- dodgr_to_igraph (graph) library (igraph) cent <- edge_betweenness (igr) identical (cent, graph$centrality) # TRUE # Values of centrality between all junctions in the contracted graph can then # be mapped back onto the original full network by \"uncontracting\": graph_full <- dodgr_uncontract_graph (graph) # For visualisation, it is generally necessary to merge the directed edges to # form an equivalent undirected graph. Conversion to 'sf' format via # 'dodgr_to_sf()' is also useful for many visualisation routines. graph_sf <- merge_directed_graph (graph_full) %>%     dodgr_to_sf () } # }  if (FALSE) { # \\dontrun{ library (mapview) centrality <- graph_sf$centrality / max (graph_sf$centrality) ncols <- 30 cols <- c (\"lawngreen\", \"red\") cols <- colorRampPalette (cols) (ncols) [ceiling (ncols * centrality)] mapview (graph_sf, color = cols, lwd = 10 * centrality) } # }  # An example of flow aggregation across a generic (non-OSM) highway, # represented as the 'routes_fast' object of the \\pkg{stplanr} package, # which is a SpatialLinesDataFrame containing commuter densities along # components of a street network. if (FALSE) { # \\dontrun{ library (stplanr) # merge all of the 'routes_fast' lines into a single network r <- overline (routes_fast, attrib = \"length\", buff_dist = 1) r <- sf::st_as_sf (r) # Convert to a 'dodgr' network, for which we need to specify both a 'type' # and 'id' column. r$type <- 1 r$id <- seq (nrow (r)) graph_full <- weight_streetnet (     r,     type_col = \"type\",     id_col = \"id\",     wt_profile = 1 ) # convert to contracted form, retaining junction vertices only, and append # 'centrality' column graph <- dodgr_contract_graph (graph_full) %>%     dodgr_centrality () #' expand back to full graph; merge directed flows; and convert result to # 'sf'-format for plotting graph_sf <- dodgr_uncontract_graph (graph) %>%     merge_directed_graph () %>%     dodgr_to_sf () plot (graph_sf [\"centrality\"]) } # }"},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_components.html","id":null,"dir":"Reference","previous_headings":"","what":"Identify connected components of graph. — dodgr_components","title":"Identify connected components of graph. — dodgr_components","text":"Identify connected components graph add corresponding component column data.frame.","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_components.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Identify connected components of graph. — dodgr_components","text":"","code":"dodgr_components(graph)"},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_components.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Identify connected components of graph. — dodgr_components","text":"graph data.frame edges","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_components.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Identify connected components of graph. — dodgr_components","text":"Equivalent graph additional component column, sequentially numbered 1 = largest component.","code":""},{"path":[]},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_components.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Identify connected components of graph. — dodgr_components","text":"","code":"graph <- weight_streetnet (hampi) graph <- dodgr_components (graph) #> graph already has a component column"},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_contract_graph.html","id":null,"dir":"Reference","previous_headings":"","what":"Contract graph to junction vertices only. — dodgr_contract_graph","title":"Contract graph to junction vertices only. — dodgr_contract_graph","text":"Removes redundant (straight-line) vertices graph, leaving junction vertices.","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_contract_graph.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Contract graph to junction vertices only. — dodgr_contract_graph","text":"","code":"dodgr_contract_graph(graph, verts = NULL, nocache = FALSE)"},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_contract_graph.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Contract graph to junction vertices only. — dodgr_contract_graph","text":"graph flat table graph edges. Must contain columns labelled , start stop. May also contain similarly labelled columns spatial coordinates (example from_x) stop_lon). verts Optional list vertices retained routing points. must match columns graph. nocache FALSE (default), load cached version contracted graph previously calculated cached. TRUE, re-contract graph even previously calculated version stored cache.","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_contract_graph.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Contract graph to junction vertices only. — dodgr_contract_graph","text":"contracted version original graph, containing number columns, row representing edge two junction vertices (submitted verts, may may junctions).","code":""},{"path":[]},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_contract_graph.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Contract graph to junction vertices only. — dodgr_contract_graph","text":"","code":"graph <- weight_streetnet (hampi) nrow (graph) # 5,973 #> [1] 6813 graph <- dodgr_contract_graph (graph) nrow (graph) # 662 #> [1] 744"},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_deduplicate_graph.html","id":null,"dir":"Reference","previous_headings":"","what":"Deduplicate edges in a graph — dodgr_deduplicate_graph","title":"Deduplicate edges in a graph — dodgr_deduplicate_graph","text":"Graph may duplicated edges, particularly extracted dodgr_streetnet objects. function de-duplicates repeated edges, reducing weighted distances times minimal values duplicates.","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_deduplicate_graph.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Deduplicate edges in a graph — dodgr_deduplicate_graph","text":"","code":"dodgr_deduplicate_graph(graph)"},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_deduplicate_graph.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Deduplicate edges in a graph — dodgr_deduplicate_graph","text":"graph 'dodgr' graph network.","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_deduplicate_graph.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Deduplicate edges in a graph — dodgr_deduplicate_graph","text":"potentially modified version graph, formerly duplicated edges reduces single rows containing minimal weighted distances times.","code":""},{"path":[]},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_distances.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate matrix of pair-wise distances between points. — dodgr_distances","title":"Calculate matrix of pair-wise distances between points. — dodgr_distances","text":"Alias dodgr_dists","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_distances.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate matrix of pair-wise distances between points. — dodgr_distances","text":"","code":"dodgr_distances(   graph,   from = NULL,   to = NULL,   shortest = TRUE,   pairwise = FALSE,   heap = \"BHeap\",   parallel = TRUE,   quiet = TRUE )"},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_distances.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate matrix of pair-wise distances between points. — dodgr_distances","text":"graph data.frame equivalent object representing network graph (see Notes). dodgr street networks, may network derived either sf silicate (\"sc\") data, generated weight_streetnet. columns graph may either single columns numeric character values specifying numbers names graph vertices, combinations two columns specifying geographical (longitude latitude,) coordinates. latter case, almost sensible combination names accepted (example, fromx, fromy, from_x, from_y, fr_lat, fr_lon.) Note longitude latitude values always interpreted 'dodgr' EPSG:4326 / WSG84 coordinates. kinds coordinates first reprojected EPSG:4326 submitting 'dodgr' routines. See information Details. Vector matrix points route distances calculated, specified one following: Single character vector precisely matching node numbers names given graph$graph$. Single vector integer-ish values, case presumed specify indices dodgr_vertices, correspond values '' '' columns graph. See example demonstration. Matrix equivalent longitude latitude coordinates, case matched nearest coordinates '' '' points graph. Vector matrix points route distances calculated. NULL, pairwise distances calculated points nodes graph. NULL, pairwise distances calculated nodes graph. shortest FALSE, calculate distances along fastest rather shortest routes. street networks produced weight_streetnet, distances may also calculated along fastest routes shortest = FALSE option. Graphs must case columns time time_weighted. Note fastest routes approximate derived sf-format data generated osmdata function osmdata_sf(), much accurate derived sc-format data generated osmdata_sc(). See weight_streetnet details. pairwise TRUE, calculate distances ordered pairs . heap Type heap use priority queue. Options include Fibonacci Heap (default; FHeap), Binary Heap (BHeap), Trinomial Heap (TriHeap), Extended Trinomial Heap (TriHeapExt, 2-3 Heap (Heap23`). parallel TRUE, perform routing calculation parallel. Calculations parallel generally advantageous. small graphs, calculating distances parallel likely offer relatively little gain speed, increases parallel computation generally markedly increase increasing graph sizes. default, parallel computation uses maximal number available cores threads. number can reduced specifying value via RcppParallel::setThreadOptions (numThreads = <desired_number>). Parallel calculations , however, able interrupted (example, Ctrl-C), can stopped killing R process. quiet FALSE, display progress messages screen.","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_distances.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate matrix of pair-wise distances between points. — dodgr_distances","text":"square matrix distances nodes","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_distances.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate matrix of pair-wise distances between points. — dodgr_distances","text":"graph must minimally contain three columns , , dist. additional column named weight wt present, shortest paths calculated according values specified column; otherwise according dist values. Either way, final distances points calculated default according values dist. , paths pair points calculated according minimal total sum weight values (present), reported distances total sums dist values.","code":""},{"path":[]},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_distances.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate matrix of pair-wise distances between points. — dodgr_distances","text":"","code":"# A simple graph graph <- data.frame (     from = c (\"A\", \"B\", \"B\", \"B\", \"C\", \"C\", \"D\", \"D\"),     to = c (\"B\", \"A\", \"C\", \"D\", \"B\", \"D\", \"C\", \"A\"),     d = c (1, 2, 1, 3, 2, 1, 2, 1) ) dodgr_dists (graph) #>   A B C D #> A 0 1 2 3 #> B 2 0 1 2 #> C 2 2 0 1 #> D 1 2 2 0  # Example of \"from\" and \"to\" as integer-ish values, in which case they are # interpreted to index into \"dodgr_vertices()\": graph <- data.frame (     from = c (1, 3, 2, 2, 3, 3, 4, 4),     to = c (2, 1, 3, 4, 2, 4, 3, 1),     d = c (1, 2, 1, 3, 2, 1, 2, 1) ) dodgr_dists (graph, from = 1, to = 2) #>   3 #> 1 2 # That then gives distance from \"1\" to \"3\" because the vertices are built # sequentially along \"graph$from\": dodgr_vertices (graph) #>   id n #> 1  1 0 #> 2  3 1 #> 3  2 2 #> 7  4 3 # And vertex$id [2] is \"3\"  # A larger example from the included [hampi()] data. graph <- weight_streetnet (hampi) from <- sample (graph$from_id, size = 100) to <- sample (graph$to_id, size = 50) d <- dodgr_dists (graph, from = from, to = to) # d is a 100-by-50 matrix of distances between `from` and `to`  if (FALSE) { # \\dontrun{ # a more complex street network example, thanks to @chrijo; see # https://github.com/UrbanAnalyst/dodgr/issues/47  xy <- rbind (     c (7.005994, 51.45774), # limbeckerplatz 1 essen germany     c (7.012874, 51.45041) ) # hauptbahnhof essen germany xy <- data.frame (lon = xy [, 1], lat = xy [, 2]) essen <- dodgr_streetnet (pts = xy, expand = 0.2, quiet = FALSE) graph <- weight_streetnet (essen, wt_profile = \"foot\") d <- dodgr_dists (graph, from = xy, to = xy) # First reason why this does not work is because the graph has multiple, # disconnected components. table (graph$component) # reduce to largest connected component, which is always number 1 graph <- graph [which (graph$component == 1), ] d <- dodgr_dists (graph, from = xy, to = xy) # should work, but even then note that table (essen$level) # There are parts of the network on different building levels (because of # shopping malls and the like). These may or may not be connected, so it may # be necessary to filter out particular levels index <- which (!(essen$level == \"-1\" | essen$level == \"1\")) # for example library (sf) # needed for following sub-select operation essen <- essen [index, ] graph <- weight_streetnet (essen, wt_profile = \"foot\") graph <- graph [which (graph$component == 1), ] d <- dodgr_dists (graph, from = xy, to = xy) } # }"},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_dists.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate matrix of pair-wise distances between points. — dodgr_dists","title":"Calculate matrix of pair-wise distances between points. — dodgr_dists","text":"Calculate matrix pair-wise distances points.","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_dists.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate matrix of pair-wise distances between points. — dodgr_dists","text":"","code":"dodgr_dists(   graph,   from = NULL,   to = NULL,   shortest = TRUE,   pairwise = FALSE,   heap = \"BHeap\",   parallel = TRUE,   quiet = TRUE )"},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_dists.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate matrix of pair-wise distances between points. — dodgr_dists","text":"graph data.frame equivalent object representing network graph (see Notes). dodgr street networks, may network derived either sf silicate (\"sc\") data, generated weight_streetnet. columns graph may either single columns numeric character values specifying numbers names graph vertices, combinations two columns specifying geographical (longitude latitude,) coordinates. latter case, almost sensible combination names accepted (example, fromx, fromy, from_x, from_y, fr_lat, fr_lon.) Note longitude latitude values always interpreted 'dodgr' EPSG:4326 / WSG84 coordinates. kinds coordinates first reprojected EPSG:4326 submitting 'dodgr' routines. See information Details. Vector matrix points route distances calculated, specified one following: Single character vector precisely matching node numbers names given graph$graph$. Single vector integer-ish values, case presumed specify indices dodgr_vertices, correspond values '' '' columns graph. See example demonstration. Matrix equivalent longitude latitude coordinates, case matched nearest coordinates '' '' points graph. Vector matrix points route distances calculated. NULL, pairwise distances calculated points nodes graph. NULL, pairwise distances calculated nodes graph. shortest FALSE, calculate distances along fastest rather shortest routes. street networks produced weight_streetnet, distances may also calculated along fastest routes shortest = FALSE option. Graphs must case columns time time_weighted. Note fastest routes approximate derived sf-format data generated osmdata function osmdata_sf(), much accurate derived sc-format data generated osmdata_sc(). See weight_streetnet details. pairwise TRUE, calculate distances ordered pairs . heap Type heap use priority queue. Options include Fibonacci Heap (default; FHeap), Binary Heap (BHeap), Trinomial Heap (TriHeap), Extended Trinomial Heap (TriHeapExt, 2-3 Heap (Heap23`). parallel TRUE, perform routing calculation parallel. Calculations parallel generally advantageous. small graphs, calculating distances parallel likely offer relatively little gain speed, increases parallel computation generally markedly increase increasing graph sizes. default, parallel computation uses maximal number available cores threads. number can reduced specifying value via RcppParallel::setThreadOptions (numThreads = <desired_number>). Parallel calculations , however, able interrupted (example, Ctrl-C), can stopped killing R process. quiet FALSE, display progress messages screen.","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_dists.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate matrix of pair-wise distances between points. — dodgr_dists","text":"square matrix distances nodes","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_dists.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate matrix of pair-wise distances between points. — dodgr_dists","text":"graph must minimally contain three columns , , dist. additional column named weight wt present, shortest paths calculated according values specified column; otherwise according dist values. Either way, final distances points calculated default according values dist. , paths pair points calculated according minimal total sum weight values (present), reported distances total sums dist values.","code":""},{"path":[]},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_dists.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate matrix of pair-wise distances between points. — dodgr_dists","text":"","code":"# A simple graph graph <- data.frame (     from = c (\"A\", \"B\", \"B\", \"B\", \"C\", \"C\", \"D\", \"D\"),     to = c (\"B\", \"A\", \"C\", \"D\", \"B\", \"D\", \"C\", \"A\"),     d = c (1, 2, 1, 3, 2, 1, 2, 1) ) dodgr_dists (graph) #>   A B C D #> A 0 1 2 3 #> B 2 0 1 2 #> C 2 2 0 1 #> D 1 2 2 0  # Example of \"from\" and \"to\" as integer-ish values, in which case they are # interpreted to index into \"dodgr_vertices()\": graph <- data.frame (     from = c (1, 3, 2, 2, 3, 3, 4, 4),     to = c (2, 1, 3, 4, 2, 4, 3, 1),     d = c (1, 2, 1, 3, 2, 1, 2, 1) ) dodgr_dists (graph, from = 1, to = 2) #>   3 #> 1 2 # That then gives distance from \"1\" to \"3\" because the vertices are built # sequentially along \"graph$from\": dodgr_vertices (graph) #>   id n #> 1  1 0 #> 2  3 1 #> 3  2 2 #> 7  4 3 # And vertex$id [2] is \"3\"  # A larger example from the included [hampi()] data. graph <- weight_streetnet (hampi) from <- sample (graph$from_id, size = 100) to <- sample (graph$to_id, size = 50) d <- dodgr_dists (graph, from = from, to = to) # d is a 100-by-50 matrix of distances between `from` and `to`  if (FALSE) { # \\dontrun{ # a more complex street network example, thanks to @chrijo; see # https://github.com/UrbanAnalyst/dodgr/issues/47  xy <- rbind (     c (7.005994, 51.45774), # limbeckerplatz 1 essen germany     c (7.012874, 51.45041) ) # hauptbahnhof essen germany xy <- data.frame (lon = xy [, 1], lat = xy [, 2]) essen <- dodgr_streetnet (pts = xy, expand = 0.2, quiet = FALSE) graph <- weight_streetnet (essen, wt_profile = \"foot\") d <- dodgr_dists (graph, from = xy, to = xy) # First reason why this does not work is because the graph has multiple, # disconnected components. table (graph$component) # reduce to largest connected component, which is always number 1 graph <- graph [which (graph$component == 1), ] d <- dodgr_dists (graph, from = xy, to = xy) # should work, but even then note that table (essen$level) # There are parts of the network on different building levels (because of # shopping malls and the like). These may or may not be connected, so it may # be necessary to filter out particular levels index <- which (!(essen$level == \"-1\" | essen$level == \"1\")) # for example library (sf) # needed for following sub-select operation essen <- essen [index, ] graph <- weight_streetnet (essen, wt_profile = \"foot\") graph <- graph [which (graph$component == 1), ] d <- dodgr_dists (graph, from = xy, to = xy) } # }"},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_dists_categorical.html","id":null,"dir":"Reference","previous_headings":"","what":"Cumulative distances along different edge categories — dodgr_dists_categorical","title":"Cumulative distances along different edge categories — dodgr_dists_categorical","text":"Cumulative distances along different edge categories","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_dists_categorical.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cumulative distances along different edge categories — dodgr_dists_categorical","text":"","code":"dodgr_dists_categorical(   graph,   from = NULL,   to = NULL,   proportions_only = FALSE,   pairwise = FALSE,   dlimit = NULL,   heap = \"BHeap\",   quiet = TRUE )"},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_dists_categorical.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cumulative distances along different edge categories — dodgr_dists_categorical","text":"graph data.frame equivalent object representing network graph must column named \"edge_type\" labels categories edge types along categorical distances aggregated (see Note). Vector matrix points route distances calculated, specified one following: Single character vector precisely matching node numbers names given graph$graph$. Single vector integer-ish values, case presumed specify indices dodgr_vertices, correspond values '' '' columns graph. See example demonstration. Matrix equivalent longitude latitude coordinates, case matched nearest coordinates '' '' points graph. Vector matrix points route distances calculated. NULL, pairwise distances calculated points nodes graph. NULL, pairwise distances calculated nodes graph. proportions_only FALSE, return distance matrices full distances edge category; TRUE, return single vector proportional distances, like summary function applied full results. See Note. pairwise TRUE, calculate distances ordered pairs . case, neither proportions_only dlimit parameters effect, result single matrix one row pair -points, one column category. dlimit value given, distances aggregated point specified distance limit (units edge distances input graph). dlimit effect specified, case proportions_only argument effect. heap Type heap use priority queue. Options include Fibonacci Heap (default; FHeap), Binary Heap (BHeap), Trinomial Heap (TriHeap), Extended Trinomial Heap (TriHeapExt, 2-3 Heap (Heap23`). quiet FALSE, display progress messages screen.","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_dists_categorical.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cumulative distances along different edge categories — dodgr_dists_categorical","text":"specified, list distance matrices equal dimensions (length(), length()), first (\"distance\") holds final distances, rest one matrix unique value \"edge_type\", holding distances traversed along types edges . Otherwise, single matrix total distances along ways point specified value dlimit, along distances along different kinds ways specified \"edge_type\" column input graph.","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_dists_categorical.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Cumulative distances along different edge categories — dodgr_dists_categorical","text":"\"edge_type\" column graph can contain kind discrete categorical values, although integer values 0 permissible. NA values ignored. function requires one full distance matrix stored category \"edge_type\" (unless proportions_only = TRUE). wise keep numbers discrete types low possible, especially large distance matrices. Setting proportions_only flag TRUE may advantageous large jobs, avoids construction full matrices. may speed calculations, perhaps importantly may make possible calculations otherwise require distance matrices large directly stored. Calculations able interrupted (example, Ctrl-C), can stopped killing R process.","code":""},{"path":[]},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_dists_categorical.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cumulative distances along different edge categories — dodgr_dists_categorical","text":"","code":"# Prepare a graph for categorical routing by including an \"edge_type\" column graph <- weight_streetnet (hampi, wt_profile = \"foot\") graph <- graph [graph$component == 1, ] graph$edge_type <- graph$highway # Define start and end points for categorical distances; using all vertices # here. length (unique (graph$edge_type)) # Number of categories #> [1] 8 v <- dodgr_vertices (graph) from <- to <- v$id [1:100] d <- dodgr_dists_categorical (graph, from, to) class (d) #> [1] \"list\"                    \"dodgr_dists_categorical\" length (d) #> [1] 9 sapply (d, dim) #>      distances path primary residential secondary service steps track #> [1,]       100  100     100         100       100     100   100   100 #> [2,]       100  100     100         100       100     100   100   100 #>      unclassified #> [1,]          100 #> [2,]          100 # 9 distance matrices, all of same dimensions, first of which is standard # distance matrix s <- summary (d) # print summary as proportions along each \"edge_type\" #> Proportional distances along each kind of edge: #>   path: 0.8941 #>   primary: 0 #>   residential: 0 #>   secondary: 0.0159 #>   service: 0.0571 #>   steps: 0 #>   track: 0 #>   unclassified: 0.0329 # or directly calculate proportions only dodgr_dists_categorical (graph, from, to,     proportions_only = TRUE ) #>         path      primary  residential    secondary      service        steps  #>   0.89410618   0.00000000   0.00000000   0.01594045   0.05706168   0.00000000  #>        track unclassified  #>   0.00000000   0.03289169   # Pairwise distances return single matrix with number of rows equal to 'from' # / 'to', and number of columns equal to number of edge types plus one for # total distances. d <- dodgr_dists_categorical (graph, from, to, pairwise = TRUE) class (d) #> [1] \"matrix\" \"array\"  dim (d) #> [1] 100   9  # The 'dlimit' parameter can be used to calculate total distances along each # category of edges from a set of points out to specified threshold: dlimit <- 2000 # in metres d <- dodgr_dists_categorical (graph, from, dlimit = dlimit) dim (d) # length(from), length(unique(edge_type)) + 1 #> [1] 100   9"},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_dists_nearest.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate vector of shortest distances from a series of 'from' points to nearest one of series of 'to' points. — dodgr_dists_nearest","title":"Calculate vector of shortest distances from a series of 'from' points to nearest one of series of 'to' points. — dodgr_dists_nearest","text":"Calculate vector shortest distances series '' points nearest one series '' points.","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_dists_nearest.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate vector of shortest distances from a series of 'from' points to nearest one of series of 'to' points. — dodgr_dists_nearest","text":"","code":"dodgr_dists_nearest(   graph,   from = NULL,   to = NULL,   shortest = TRUE,   heap = \"BHeap\",   quiet = TRUE )"},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_dists_nearest.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate vector of shortest distances from a series of 'from' points to nearest one of series of 'to' points. — dodgr_dists_nearest","text":"graph data.frame equivalent object representing network graph (see Notes). dodgr street networks, may network derived either sf silicate (\"sc\") data, generated weight_streetnet. columns graph may either single columns numeric character values specifying numbers names graph vertices, combinations two columns specifying geographical (longitude latitude,) coordinates. latter case, almost sensible combination names accepted (example, fromx, fromy, from_x, from_y, fr_lat, fr_lon.) Note longitude latitude values always interpreted 'dodgr' EPSG:4326 / WSG84 coordinates. kinds coordinates first reprojected EPSG:4326 submitting 'dodgr' routines. See information Details. Vector matrix points route distances calculated, specified one following: Single character vector precisely matching node numbers names given graph$graph$. Single vector integer-ish values, case presumed specify indices dodgr_vertices, correspond values '' '' columns graph. See example demonstration. Matrix equivalent longitude latitude coordinates, case matched nearest coordinates '' '' points graph. Vector matrix points route distances calculated. NULL, pairwise distances calculated points nodes graph. NULL, pairwise distances calculated nodes graph. shortest FALSE, calculate distances along fastest rather shortest routes. street networks produced weight_streetnet, distances may also calculated along fastest routes shortest = FALSE option. Graphs must case columns time time_weighted. Note fastest routes approximate derived sf-format data generated osmdata function osmdata_sf(), much accurate derived sc-format data generated osmdata_sc(). See weight_streetnet details. heap Type heap use priority queue. Options include Fibonacci Heap (default; FHeap), Binary Heap (BHeap), Trinomial Heap (TriHeap), Extended Trinomial Heap (TriHeapExt, 2-3 Heap (Heap23`). quiet FALSE, display progress messages screen.","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_dists_nearest.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate vector of shortest distances from a series of 'from' points to nearest one of series of 'to' points. — dodgr_dists_nearest","text":"Vector distances, one element '' point giving distance nearest '' point.","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_dists_nearest.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Calculate vector of shortest distances from a series of 'from' points to nearest one of series of 'to' points. — dodgr_dists_nearest","text":"graph must minimally contain three columns , , dist. additional column named weight wt present, shortest paths calculated according values specified column; otherwise according dist values. Either way, final distances points calculated default according values dist. , paths pair points calculated according minimal total sum weight values (present), reported distances total sums dist values. street networks produced weight_streetnet, distances may also calculated along fastest routes shortest = FALSE option. Graphs must case columns time time_weighted. Note fastest routes approximate derived sf-format data generated osmdata function osmdata_sf(), much accurate derived sc-format data generated osmdata_sc(). See weight_streetnet details. columns graph may either single columns numeric character values specifying numbers names graph vertices, combinations two columns specifying geographical (longitude latitude) coordinates. latter case, almost sensible combination names accepted (example, fromx, fromy, from_x, from_y, fr_lat, fr_lon.) values can either two-column matrices equivalent longitude latitude coordinates, else single columns precisely matching node numbers names given graph$graph$. NULL, pairwise distances calculated points nodes graph. NULL, pairwise distances calculated nodes graph. Calculations always calculated parallel, using multiple threads.","code":""},{"path":[]},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_dists_nearest.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate vector of shortest distances from a series of 'from' points to nearest one of series of 'to' points. — dodgr_dists_nearest","text":"","code":"# A simple graph graph <- data.frame (     from = c (\"A\", \"B\", \"B\", \"B\", \"C\", \"C\", \"D\", \"D\"),     to = c (\"B\", \"A\", \"C\", \"D\", \"B\", \"D\", \"C\", \"A\"),     d = c (1, 2, 1, 3, 2, 1, 2, 1) ) dodgr_dists (graph) #>   A B C D #> A 0 1 2 3 #> B 2 0 1 2 #> C 2 2 0 1 #> D 1 2 2 0  # A larger example from the included [hampi()] data. graph <- weight_streetnet (hampi) from <- sample (graph$from_id, size = 100) to <- sample (graph$to_id, size = 50) d <- dodgr_dists (graph, from = from, to = to) # d is a 100-by-50 matrix of distances between `from` and `to`  if (FALSE) { # \\dontrun{ # a more complex street network example, thanks to @chrijo; see # https://github.com/UrbanAnalyst/dodgr/issues/47  xy <- rbind (     c (7.005994, 51.45774), # limbeckerplatz 1 essen germany     c (7.012874, 51.45041) ) # hauptbahnhof essen germany xy <- data.frame (lon = xy [, 1], lat = xy [, 2]) essen <- dodgr_streetnet (pts = xy, expand = 0.2, quiet = FALSE) graph <- weight_streetnet (essen, wt_profile = \"foot\") d <- dodgr_dists (graph, from = xy, to = xy) # First reason why this does not work is because the graph has multiple, # disconnected components. table (graph$component) # reduce to largest connected component, which is always number 1 graph <- graph [which (graph$component == 1), ] d <- dodgr_dists (graph, from = xy, to = xy) # should work, but even then note that table (essen$level) # There are parts of the network on different building levels (because of # shopping malls and the like). These may or may not be connected, so it may # be necessary to filter out particular levels index <- which (!(essen$level == \"-1\" | essen$level == \"1\")) # for example library (sf) # needed for following sub-select operation essen <- essen [index, ] graph <- weight_streetnet (essen, wt_profile = \"foot\") graph <- graph [which (graph$component == 1), ] d <- dodgr_dists (graph, from = xy, to = xy) } # }"},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_flowmap.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a map of dodgr flows. — dodgr_flowmap","title":"Create a map of dodgr flows. — dodgr_flowmap","text":"Create map output dodgr_flows_aggregate dodgr_flows_disperse","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_flowmap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a map of dodgr flows. — dodgr_flowmap","text":"","code":"dodgr_flowmap(net, bbox = NULL, linescale = 1)"},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_flowmap.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a map of dodgr flows. — dodgr_flowmap","text":"net street network flow column obtained dodgr_flows_aggregate dodgr_flows_disperse bbox given, scale map bbox, otherwise use entire extend net linescale Maximal thickness plotted lines","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_flowmap.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Create a map of dodgr flows. — dodgr_flowmap","text":"net first passed merge_directed_graph prior plotting, otherwise lines different directions overlaid.","code":""},{"path":[]},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_flowmap.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a map of dodgr flows. — dodgr_flowmap","text":"","code":"graph <- weight_streetnet (hampi) from <- sample (graph$from_id, size = 10) to <- sample (graph$to_id, size = 5) to <- to [!to %in% from] flows <- matrix (     10 * runif (length (from) * length (to)),     nrow = length (from) ) graph <- dodgr_flows_aggregate (graph, from = from, to = to, flows = flows) # graph then has an additonal 'flows` column of aggregate flows along all # edges. These flows are directed, and can be aggregated to equivalent # undirected flows on an equivalent undirected graph with: graph_undir <- merge_directed_graph (graph) if (FALSE) { # \\dontrun{ dodgr_flowmap (graph_undir) } # }"},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_flows_aggregate.html","id":null,"dir":"Reference","previous_headings":"","what":"Aggregate flows throughout a network. — dodgr_flows_aggregate","title":"Aggregate flows throughout a network. — dodgr_flows_aggregate","text":"Aggregate flows throughout network based input matrix flows pairs points. Flows calculated default contracted graphs, via contract = TRUE parameter. (derived reducing input graph junction vertices , joining intermediate edges junction.) changes input graph prompt changes resultant flows, default contract = TRUE used, may calculations using previously cached versions contracted graph. , please use either clear_dodgr_cache remove cached version, dodgr_cache_off prior initial graph construction switch cache completely.","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_flows_aggregate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Aggregate flows throughout a network. — dodgr_flows_aggregate","text":"","code":"dodgr_flows_aggregate(   graph,   from,   to,   flows,   pairwise = FALSE,   contract = TRUE,   heap = \"BHeap\",   tol = 0.000000000001,   norm_sums = TRUE,   quiet = TRUE )"},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_flows_aggregate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Aggregate flows throughout a network. — dodgr_flows_aggregate","text":"graph data.frame equivalent object representing network graph (see Details) Vector matrix points route distances calculated, specified one following: Single character vector precisely matching node numbers names given graph$graph$. Single vector integer-ish values, case presumed specify indices dodgr_vertices, correspond values '' '' columns graph. See example demonstration. Matrix equivalent longitude latitude coordinates, case matched nearest coordinates '' '' points graph. Vector matrix points route distances calculated. NULL, pairwise distances calculated points nodes graph. NULL, pairwise distances calculated nodes graph. flows Matrix flows nrow(flows)==length() ncol(flows)==length(). pairwise TRUE, aggregate flows paths connecting ordered pairs . case, must length, flows must either vector length, matrix one column number rows. flows quantifies flows pair points. contract TRUE (default), calculate flows contracted graph mapping back original full graph (recommended generally much faster). FALSE used graph already contracted. heap Type heap use priority queue. Options include Fibonacci Heap (default; FHeap), Binary Heap (BHeap), Trinomial Heap (TriHeap), Extended Trinomial Heap (TriHeapExt, 2-3 Heap (Heap23). tol Relative tolerance flows towards vertices considered. generally effect, can provide speed gains flow matrices represent spatial interaction models, case parameter effectively reduces radius point flows aggregated. remove effect, set tol = 0. norm_sums Standardise sums origin points, sum flows throughout entire network equals sum densities origins (see Note). quiet FALSE, display progress messages screen.","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_flows_aggregate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Aggregate flows throughout a network. — dodgr_flows_aggregate","text":"Modified version graph additional flow column added.","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_flows_aggregate.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Aggregate flows throughout a network. — dodgr_flows_aggregate","text":"norm_sums parameter used whenever densities origins destinations absolute values, ensures sum resultant flow values throughout entire network equals sum densities origins. example, norm_sums = TRUE (default), flow single origin density one single destination along two edges allocate flows one half edges, sum flows across network equal one, sum densities origins. norm_sums = TRUE option appropriate densities relative values, ensures edge maintains relative proportions. example, flows along two edges equal one, network sum two, greater sum densities. Flows calculated default using parallel computation maximal number available cores threads. number can reduced specifying value via RcppParallel::setThreadOptions (numThreads = <desired_number>).","code":""},{"path":[]},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_flows_aggregate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Aggregate flows throughout a network. — dodgr_flows_aggregate","text":"","code":"graph <- weight_streetnet (hampi) from <- sample (graph$from_id, size = 10) to <- sample (graph$to_id, size = 5) to <- to [!to %in% from] flows <- matrix (10 * runif (length (from) * length (to)),     nrow = length (from) ) graph <- dodgr_flows_aggregate (graph, from = from, to = to, flows = flows) # graph then has an additonal 'flows' column of aggregate flows along all # edges. These flows are directed, and can be aggregated to equivalent # undirected flows on an equivalent undirected graph with: graph_undir <- merge_directed_graph (graph) # This graph will only include those edges having non-zero flows, and so: nrow (graph) #> [1] 6813 nrow (graph_undir) # the latter is much smaller #> [1] 996  # The following code can be used to convert the resultant graph to an `sf` # object suitable for plotting if (FALSE) { # \\dontrun{ gsf <- dodgr_to_sf (graph_undir)  # example of plotting with the 'mapview' package library (mapview) flow <- gsf$flow / max (gsf$flow) ncols <- 30 cols <- c (\"lawngreen\", \"red\") colranmp <- colorRampPalette (cols) (ncols) [ceiling (ncols * flow)] mapview (gsf, color = colranmp, lwd = 10 * flow) } # }  # An example of flow aggregation across a generic (non-OSM) highway, # represented as the `routes_fast` object of the \\pkg{stplanr} package, # which is a SpatialLinesDataFrame containing commuter densities along # components of a street network. if (FALSE) { # \\dontrun{ library (stplanr) # merge all of the 'routes_fast' lines into a single network r <- overline (routes_fast, attrib = \"length\", buff_dist = 1) r <- sf::st_as_sf (r) # then extract the start and end points of each of the original 'routes_fast' # lines and use these for routing with `dodgr` l <- lapply (routes_fast@lines, function (i) {     c (         sp::coordinates (i) [[1]] [1, ],         tail (sp::coordinates (i) [[1]], 1)     ) }) l <- do.call (rbind, l) xy_start <- l [, 1:2] xy_end <- l [, 3:4] # Then just specify a generic OD matrix with uniform values of 1: flows <- matrix (1, nrow = nrow (l), ncol = nrow (l)) # We need to specify both a `type` and `id` column for the # \\link{weight_streetnet} function. r$type <- 1 r$id <- seq (nrow (r)) graph <- weight_streetnet (     r,     type_col = \"type\",     id_col = \"id\",     wt_profile = 1 ) f <- dodgr_flows_aggregate (     graph,     from = xy_start,     to = xy_end,     flows = flows ) # Then merge directed flows and convert to \\pkg{sf} for plotting as before: f <- merge_directed_graph (f) geoms <- dodgr_to_sfc (f) gc <- dodgr_contract_graph (f) gsf <- sf::st_sf (geoms) gsf$flow <- gc$flow # sf plot: plot (gsf [\"flow\"]) } # }"},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_flows_disperse.html","id":null,"dir":"Reference","previous_headings":"","what":"Aggregate flows dispersed from each point in a network. — dodgr_flows_disperse","title":"Aggregate flows dispersed from each point in a network. — dodgr_flows_disperse","text":"Disperse flows throughout network based input vectors origin points associated densities. Dispersal implemented exponential decay, controlled parameter, k, flows decay exp(-d / k), d distance. algorithm allows efficient fitting multiple dispersal models different coefficients fitted single call. Values dispersal coefficients, k, may take one following forms: single numeric value (> 0), dispersal along paths calculated single value. Return object (see ) single additional column named \"flow\". vector length equal number points, dispersal point calculated using corresponding value k. Return object single additional \"flow\" column. vector length (, >  1 yet different number points), case different dispersal models fitted n specified values, resultant return object additional 'n' columns, named 'flow1', 'flow2', ... 'n'. columns must subsequently matched user back corresponding 'k' values. matrix number rows equal number points, number columns. column specify distinct dispersal model, different values row applied corresponding points. return value previous version, additional n columns, \"flow1\" \"flow\". Flows calculated default contracted graphs, via contract = TRUE parameter. (derived reducing input graph junction vertices , joining intermediate edges junction.) changes input graph prompt changes resultant flows, default contract = TRUE used, may calculations using previously cached versions contracted graph. , please use either clear_dodgr_cache remove cached version, dodgr_cache_off prior initial graph construction switch cache completely.","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_flows_disperse.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Aggregate flows dispersed from each point in a network. — dodgr_flows_disperse","text":"","code":"dodgr_flows_disperse(   graph,   from,   dens,   k = 500,   contract = TRUE,   heap = \"BHeap\",   tol = 0.000000000001,   quiet = TRUE )"},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_flows_disperse.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Aggregate flows dispersed from each point in a network. — dodgr_flows_disperse","text":"graph data.frame equivalent object representing network graph (see Details) Vector matrix points aggregate dispersed flows calculated (see Details) dens Vectors densities corresponding points k Width coefficient exponential diffusion function defined exp(-d/k), units distance column graph (metres default). Can also vector length , giving dispersal coefficients point. value k<0 given, standard logistic polynomial used. contract TRUE (default), calculate flows contracted graph mapping back original full graph (recommended generally much faster). FALSE used graph already contracted. heap Type heap use priority queue. Options include Fibonacci Heap (default; FHeap), Binary Heap (BHeap), Trinomial Heap (TriHeap), Extended Trinomial Heap (TriHeapExt, 2-3 Heap (Heap23). tol Relative tolerance dispersal considered finished. parameter can generally ignored; doubt, effect can removed setting tol = 0. quiet FALSE, display progress messages screen.","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_flows_disperse.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Aggregate flows dispersed from each point in a network. — dodgr_flows_disperse","text":"Modified version graph additional flow column added.","code":""},{"path":[]},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_flows_disperse.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Aggregate flows dispersed from each point in a network. — dodgr_flows_disperse","text":"","code":"# This is generally needed to explore different values of `k` on same graph: dodgr_cache_off ()  graph <- weight_streetnet (hampi) from <- sample (graph$from_id, size = 10) dens <- rep (1, length (from)) # Uniform densities graph <- dodgr_flows_disperse (graph, from = from, dens = dens) # graph then has an additonal 'flows` column of aggregate flows along all # edges. These flows are directed, and can be aggregated to equivalent # undirected flows on an equivalent undirected graph with: graph_undir <- merge_directed_graph (graph)  # Remove `flow` column to avoid warning about over-writing values: graph$flow <- NULL # One dispersal coefficient for each origin point: k <- runif (length (from)) graph <- dodgr_flows_disperse (graph, from = from, dens = dens, k = k) grep (\"^flow\", names (graph), value = TRUE) #> [1] \"flow\" # single dispersal model; single \"flow\" column  # Multiple models, muliple dispersal coefficients: k <- 1:5 graph$flow <- NULL graph <- dodgr_flows_disperse (graph, from = from, dens = dens, k = k) grep (\"^flow\", names (graph), value = TRUE) #> [1] \"flow1\" \"flow2\" \"flow3\" \"flow4\" \"flow5\" # Rm all flow columns: graph [grep (\"^flow\", names (graph), value = TRUE)] <- NULL  # Multiple models with unique coefficient at each origin point: k <- matrix (runif (length (from) * 5), ncol = 5) dim (k) #> [1] 10  5 graph <- dodgr_flows_disperse (graph, from = from, dens = dens, k = k) grep (\"^flow\", names (graph), value = TRUE) #> [1] \"flow1\" \"flow2\" \"flow3\" \"flow4\" \"flow5\" # 5 \"flow\" columns again, but this time different dispersal coefficients each # each origin point."},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_flows_si.html","id":null,"dir":"Reference","previous_headings":"","what":"Aggregate flows throughout a network using a spatial interaction model. — dodgr_flows_si","title":"Aggregate flows throughout a network using a spatial interaction model. — dodgr_flows_si","text":"Aggregate flows throughout network using exponential Spatial Interaction (SI) model specified set origin destination points, associated vectors densities. Spatial interactions implemented using exponential decay, controlled parameter, k, interactions decay exp(-d / k), d distance. algorithm allows efficient fitting multiple interaction models different coefficients fitted single call. Values interaction coefficients, k, may take one following forms: single numeric value (> 0), interactions along paths calculated single value. Return object (see ) single additional column named \"flow\". vector length equal number points, interactions point calculated using corresponding value k. Return object single additional \"flow\" column. vector length (, >  1 yet different number points), case different interaction models fitted n specified values, resultant return object additional 'n' columns, named 'flow1', 'flow2', ... 'n'. columns must subsequently matched user back corresponding 'k' values. matrix number rows equal number points, number columns. column specify distinct interaction model, different values row applied corresponding points. return value previous version, additional n columns, \"flow1\" \"flow\". Flows calculated default contracted graphs, via contract = TRUE parameter. (derived reducing input graph junction vertices , joining intermediate edges junction.) changes input graph prompt changes resultant flows, default contract = TRUE used, may calculations using previously cached versions contracted graph. , please use either clear_dodgr_cache remove cached version, dodgr_cache_off prior initial graph construction switch cache completely.","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_flows_si.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Aggregate flows throughout a network using a spatial interaction model. — dodgr_flows_si","text":"","code":"dodgr_flows_si(   graph,   from,   to,   k = 500,   dens_from = NULL,   dens_to = NULL,   contract = TRUE,   norm_sums = TRUE,   heap = \"BHeap\",   tol = 0.000000000001,   quiet = TRUE )"},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_flows_si.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Aggregate flows throughout a network using a spatial interaction model. — dodgr_flows_si","text":"graph data.frame equivalent object representing network graph (see Details) Vector matrix points route distances calculated, specified one following: Single character vector precisely matching node numbers names given graph$graph$. Single vector integer-ish values, case presumed specify indices dodgr_vertices, correspond values '' '' columns graph. See example demonstration. Matrix equivalent longitude latitude coordinates, case matched nearest coordinates '' '' points graph. Vector matrix points route distances calculated. NULL, pairwise distances calculated points nodes graph. NULL, pairwise distances calculated nodes graph. k Width exponential spatial interaction function (exp (-d / k)), units 'd', specified one 3 forms: () single value; (ii) vector independent values origin point (length '' points); (iii) equivalent matrix column holding values '' point, 'nrow(k)==length()'. See Note. dens_from Vector densities origin ('') points dens_to Vector densities destination ('') points contract TRUE (default), calculate flows contracted graph mapping back original full graph (recommended generally much faster). FALSE used graph already contracted. norm_sums Standardise sums origin points, sum flows throughout entire network equals sum densities origins (see Note). heap Type heap use priority queue. Options include Fibonacci Heap (default; FHeap), Binary Heap (BHeap), Trinomial Heap (TriHeap), Extended Trinomial Heap (TriHeapExt, 2-3 Heap (Heap23). tol Relative tolerance flows towards vertices considered. generally effect, can provide speed gains flow matrices represent spatial interaction models, case parameter effectively reduces radius point flows aggregated. remove effect, set tol = 0. quiet FALSE, display progress messages screen.","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_flows_si.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Aggregate flows throughout a network using a spatial interaction model. — dodgr_flows_si","text":"Modified version graph additional flow column added.","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_flows_si.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Aggregate flows throughout a network using a spatial interaction model. — dodgr_flows_si","text":"norm_sums parameter used whenever densities origins destinations absolute values, ensures sum resultant flow values throughout entire network equals sum densities origins. example, norm_sums = TRUE (default), flow single origin density one single destination along two edges allocate flows one half edges, sum flows across network equal one, sum densities origins. norm_sums = TRUE option appropriate densities relative values, ensures edge maintains relative proportions. example, flows along two edges equal one, network sum two, greater sum densities. norm_sums = TRUE, sum network flows (sum(output$flow)) equal sum origin densities (sum(dens_from)). may nevertheless always case, origin points may simply far destination () points exponential model yield non-zero values anywhere network within machine tolerance. cases may result sums output flows less sums input densities.","code":""},{"path":[]},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_flows_si.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Aggregate flows throughout a network using a spatial interaction model. — dodgr_flows_si","text":"","code":"# This is generally needed to explore different values of `k` on same graph: dodgr_cache_off ()  graph <- weight_streetnet (hampi) from <- sample (graph$from_id, size = 10) to <- sample (graph$from_id, size = 20) dens_from <- runif (length (from)) dens_to <- runif (length (to)) graph <- dodgr_flows_si (     graph,     from = from,     to = to,     dens_from = dens_from,     dens_to = dens_to ) # graph then has an additonal 'flows' column of aggregate flows along all # edges. These flows are directed, and can be aggregated to equivalent # undirected flows on an equivalent undirected graph with: graph_undir <- merge_directed_graph (graph) # This graph will only include those edges having non-zero flows, and so: nrow (graph) #> [1] 6813 nrow (graph_undir) # the latter is much smaller #> [1] 1302  # ----- One dispersal coefficient for each origin point: # Remove `flow` column to avoid warning about over-writing values: graph$flow <- NULL k <- runif (length (from)) graph <- dodgr_flows_si (     graph,     from = from,     to = to,     dens_from = dens_from,     dens_to = dens_to,     k = k ) grep (\"^flow\", names (graph), value = TRUE) #> [1] \"flow\" # single dispersal model; single \"flow\" column  # ----- Multiple models, muliple dispersal coefficients: k <- 1:5 graph$flow <- NULL graph <- dodgr_flows_si (     graph,     from = from,     to = to,     dens_from = dens_from,     dens_to = dens_to,     k = k ) grep (\"^flow\", names (graph), value = TRUE) #> [1] \"flow1\" \"flow2\" \"flow3\" \"flow4\" \"flow5\" # Rm all flow columns: graph [grep (\"^flow\", names (graph), value = TRUE)] <- NULL  # Multiple models with unique coefficient at each origin point: k <- matrix (runif (length (from) * 5), ncol = 5) dim (k) #> [1] 10  5 graph <- dodgr_flows_si (     graph,     from = from,     to = to,     dens_from = dens_from,     dens_to = dens_to,     k = k ) grep (\"^flow\", names (graph), value = TRUE) #> [1] \"flow1\" \"flow2\" \"flow3\" \"flow4\" \"flow5\" # 5 \"flow\" columns again, but this time different dispersal coefficients each # each origin point."},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_full_cycles.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate fundamental cycles on a FULL (that is, non-contracted) graph. — dodgr_full_cycles","title":"Calculate fundamental cycles on a FULL (that is, non-contracted) graph. — dodgr_full_cycles","text":"Calculate fundamental cycles FULL (, non-contracted) graph.","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_full_cycles.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate fundamental cycles on a FULL (that is, non-contracted) graph. — dodgr_full_cycles","text":"","code":"dodgr_full_cycles(graph, graph_max_size = 10000, expand = 0.05)"},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_full_cycles.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate fundamental cycles on a FULL (that is, non-contracted) graph. — dodgr_full_cycles","text":"graph data.frame equivalent object representing contracted network graph (see Details). graph_max_size Maximum size submitted internal C++ routines single chunk. Warning: Increasing may lead computer meltdown! expand large graphs must broken chunks, factor determines relative overlap chunks ensure cycles captured. (value need modified special cases.)","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_full_cycles.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Calculate fundamental cycles on a FULL (that is, non-contracted) graph. — dodgr_full_cycles","text":"function converts graph contracted form, calculates fundamental cycles version, expands cycles back onto original graph. far computationally efficient calculating fundamental cycles full (non-contracted) graph.","code":""},{"path":[]},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_full_cycles.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate fundamental cycles on a FULL (that is, non-contracted) graph. — dodgr_full_cycles","text":"","code":"if (FALSE) { # \\dontrun{ net <- weight_streetnet (hampi) graph <- dodgr_contract_graph (net) cyc1 <- dodgr_fundamental_cycles (graph) cyc2 <- dodgr_full_cycles (net) } # } # cyc2 has same number of cycles, but each one is generally longer, through # including all points intermediate to junctions; cyc1 has cycles composed of # junction points only."},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_fundamental_cycles.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate fundamental cycles in a graph. — dodgr_fundamental_cycles","title":"Calculate fundamental cycles in a graph. — dodgr_fundamental_cycles","text":"Calculate fundamental cycles graph.","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_fundamental_cycles.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate fundamental cycles in a graph. — dodgr_fundamental_cycles","text":"","code":"dodgr_fundamental_cycles(   graph,   vertices = NULL,   graph_max_size = 10000,   expand = 0.05 )"},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_fundamental_cycles.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate fundamental cycles in a graph. — dodgr_fundamental_cycles","text":"graph data.frame equivalent object representing contracted network graph (see Details). vertices data.frame returned dodgr_vertices(graph). calculated provided, quicker pass already calculated. graph_max_size Maximum size submitted internal C++ routines single chunk. Warning: Increasing may lead computer meltdown! expand large graphs must broken chunks, factor determines relative overlap chunks ensure cycles captured. (value need modified special cases.)","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_fundamental_cycles.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate fundamental cycles in a graph. — dodgr_fundamental_cycles","text":"List cycle paths, terms vertex IDs graph , spatial graphs, corresponding coordinates.","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_fundamental_cycles.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Calculate fundamental cycles in a graph. — dodgr_fundamental_cycles","text":"Calculation fundamental cycles computationally demanding, function executed CONTRACTED graphs (, graphs returned dodgr_contract_graph), even may take long time execute. Results full graphs can obtained function dodgr_full_cycles. computational complexity can also calculated advance, parameter graph_max_size lead graphs larger (measured numbers edges) cut smaller parts. (Note possible spatial graphs, meaning possible apply function large, non-spatial graphs.) smaller parts expanded specified amount (expand), cycles found within. final result obtained aggregating cycles removing repeated ones arising due overlap expanded portions. Finally, note procedure cutting graphs smaller, computationally manageable sub-graphs provides approximation may yield fundamental cycles.","code":""},{"path":[]},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_fundamental_cycles.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate fundamental cycles in a graph. — dodgr_fundamental_cycles","text":"","code":"net <- weight_streetnet (hampi) graph <- dodgr_contract_graph (net) verts <- dodgr_vertices (graph) cyc <- dodgr_fundamental_cycles (graph, verts)"},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_insert_vertex.html","id":null,"dir":"Reference","previous_headings":"","what":"Insert a new node or vertex into a network — dodgr_insert_vertex","title":"Insert a new node or vertex into a network — dodgr_insert_vertex","text":"Insert new node vertex network","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_insert_vertex.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Insert a new node or vertex into a network — dodgr_insert_vertex","text":"","code":"dodgr_insert_vertex(graph, v1, v2, x = NULL, y = NULL)"},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_insert_vertex.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Insert a new node or vertex into a network — dodgr_insert_vertex","text":"graph flat table graph edges. Must contain columns labelled , start stop. May also contain similarly labelled columns spatial coordinates (example from_x) stop_lon). v1 Vertex defining start graph edge along new vertex inserted v2 Vertex defining end graph edge along new vertex inserted (order v1 v2 important). x x-coordinate new vertex. specified, vertex created half-way v1 v2. y y-coordinate new vertex. specified, vertex created half-way v1 v2.","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_insert_vertex.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Insert a new node or vertex into a network — dodgr_insert_vertex","text":"modified graph specified edge defined start end vertices split two edges either side new vertex.","code":""},{"path":[]},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_insert_vertex.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Insert a new node or vertex into a network — dodgr_insert_vertex","text":"","code":"graph <- weight_streetnet (hampi) e1 <- sample (nrow (graph), 1) v1 <- graph$from_id [e1] v2 <- graph$to_id [e1] # insert new vertex in the middle of that randomly-selected edge: graph2 <- dodgr_insert_vertex (graph, v1, v2) nrow (graph) #> [1] 6813 nrow (graph2) # new edges added to graph2 #> [1] 6815"},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_isochrones.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate isochrone contours from specified points. — dodgr_isochrones","title":"Calculate isochrone contours from specified points. — dodgr_isochrones","text":"Function fully vectorized calculate accept vectors central points vectors defining multiple isochrone thresholds.","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_isochrones.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate isochrone contours from specified points. — dodgr_isochrones","text":"","code":"dodgr_isochrones(   graph,   from = NULL,   tlim = NULL,   concavity = 0,   length_threshold = 0,   heap = \"BHeap\" )"},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_isochrones.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate isochrone contours from specified points. — dodgr_isochrones","text":"graph data.frame equivalent object representing network graph. dodgr street networks, must network derived silicate (\"sc\") data, generated weight_streetnet. function work networks derived sf data. Vector matrix points isochrones calculated. tlim Vector desired limits isochrones seconds concavity value 0 1, 0 giving (generally smoother less detailed) convex iso-contours 1 giving highly concave (generally detailed) contours. length_threshold minimal length segment iso-contour made convex according 'concavity` parameter.. Low values produce highly detailed hulls may cause problems; doubt, odd results appear, increase value. heap Type heap use priority queue. Options include Fibonacci Heap (default; FHeap), Binary Heap (BHeap), Trinomial Heap (TriHeap), Extended Trinomial Heap (TriHeapExt, 2-3 Heap (Heap23).","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_isochrones.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate isochrone contours from specified points. — dodgr_isochrones","text":"single data.frame isochrones points sorted anticlockwise around origin () point, columns denoting points tlim value(s). isochrones given id values associated coordinates series points point specified isochrone times. Isochrones calculated default using parallel computation maximal number available cores threads. number can reduced specifying value via RcppParallel::setThreadOptions (numThreads = <desired_number>).","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_isochrones.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Calculate isochrone contours from specified points. — dodgr_isochrones","text":"Isodists calculated default using parallel computation maximal number available cores threads. number can reduced specifying value via RcppParallel::setThreadOptions (numThreads = <desired_number>).","code":""},{"path":[]},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_isochrones.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate isochrone contours from specified points. — dodgr_isochrones","text":"","code":"if (FALSE) { # \\dontrun{ # Use osmdata package to extract 'SC'-format data: library (osmdata) dat <- opq (\"hampi india\") %>%     add_osm_feature (key = \"highway\") %>%     osmdata_sc () graph <- weight_streetnet (dat) from <- sample (graph$.vx0, size = 100) tlim <- c (5, 10, 20, 30, 60) * 60 # times in seconds x <- dodgr_isochrones (graph, from = from, tlim) } # }"},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_isodists.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate isodistance contours from specified points. — dodgr_isodists","title":"Calculate isodistance contours from specified points. — dodgr_isodists","text":"Function fully vectorized calculate accept vectors central points vectors defining multiple isodistances.","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_isodists.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate isodistance contours from specified points. — dodgr_isodists","text":"","code":"dodgr_isodists(   graph,   from = NULL,   dlim = NULL,   concavity = 0,   length_threshold = 0,   contract = TRUE,   heap = \"BHeap\" )"},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_isodists.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate isodistance contours from specified points. — dodgr_isodists","text":"graph data.frame equivalent object representing network graph. dodgr street networks, may network derived either sf silicate (\"sc\") data, generated weight_streetnet. Vector matrix points isodistances calculated. dlim Vector desired limits isodistances metres. concavity value 0 1, 0 giving (generally smoother less detailed) convex iso-contours 1 giving highly concave (generally detailed) contours. length_threshold minimal length segment iso-contour made convex according 'concavity` parameter.. Low values produce highly detailed hulls may cause problems; doubt, odd results appear, increase value. contract TRUE, calculate isodists vertices contract graph, words, junction vertices. heap Type heap use priority queue. Options include Fibonacci Heap (default; FHeap), Binary Heap (BHeap), Trinomial Heap (TriHeap), Extended Trinomial Heap (TriHeapExt, 2-3 Heap (Heap23).","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_isodists.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate isodistance contours from specified points. — dodgr_isodists","text":"single data.frame isodistances points sorted anticlockwise around origin () point, columns denoting points dlim value(s). isodistance contours given id values associated coordinates series points point specified isodistances.","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_isodists.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Calculate isodistance contours from specified points. — dodgr_isodists","text":"Isodists calculated default using parallel computation maximal number available cores threads. number can reduced specifying value via RcppParallel::setThreadOptions (numThreads = <desired_number>).","code":""},{"path":[]},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_isodists.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate isodistance contours from specified points. — dodgr_isodists","text":"","code":"graph <- weight_streetnet (hampi) from <- sample (graph$from_id, size = 100) dlim <- c (1, 2, 5, 10, 20) * 100 d <- dodgr_isodists (graph, from = from, dlim)"},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_isoverts.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate isodistance or isochrone contours from specified points. — dodgr_isoverts","title":"Calculate isodistance or isochrone contours from specified points. — dodgr_isoverts","text":"Returns lists network vertices contained within contours. Function fully vectorized calculate accept vectors central points vectors defining multiple isochrone thresholds. Provide one dlim values isodistances, one tlim values isochrones.","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_isoverts.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate isodistance or isochrone contours from specified points. — dodgr_isoverts","text":"","code":"dodgr_isoverts(graph, from = NULL, dlim = NULL, tlim = NULL, heap = \"BHeap\")"},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_isoverts.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate isodistance or isochrone contours from specified points. — dodgr_isoverts","text":"graph data.frame equivalent object representing network graph. dodgr street networks, must network derived silicate (\"sc\") data, generated weight_streetnet. function work networks derived sf data. Vector matrix points isodistances isochrones calculated. dlim Vector desired limits isodistances metres. tlim Vector desired limits isochrones seconds heap Type heap use priority queue. Options include Fibonacci Heap (default; FHeap), Binary Heap (BHeap), Trinomial Heap (TriHeap), Extended Trinomial Heap (TriHeapExt, 2-3 Heap (Heap23).","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_isoverts.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate isodistance or isochrone contours from specified points. — dodgr_isoverts","text":"single data.frame vertex IDs, columns denoting points tlim value(s). isochrones given id values associated coordinates series points point specified isochrone times. Isoverts calculated default using parallel computation maximal number available cores threads. number can reduced specifying value via RcppParallel::setThreadOptions (numThreads = <desired_number>).","code":""},{"path":[]},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_isoverts.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate isodistance or isochrone contours from specified points. — dodgr_isoverts","text":"","code":"if (FALSE) { # \\dontrun{ # Use osmdata package to extract 'SC'-format data: library (osmdata) dat <- opq (\"hampi india\") %>%     add_osm_feature (key = \"highway\") %>%     osmdata_sc () graph <- weight_streetnet (dat) from <- sample (graph$.vx0, size = 100) tlim <- c (5, 10, 20, 30, 60) * 60 # times in seconds x <- dodgr_isoverts (graph, from = from, tlim) } # }"},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_load_streetnet.html","id":null,"dir":"Reference","previous_headings":"","what":"Load a street network previously saved with dodgr_save_streetnet. — dodgr_load_streetnet","title":"Load a street network previously saved with dodgr_save_streetnet. — dodgr_load_streetnet","text":"always returns full, non-contracted graph. contracted graph can generated passing result dodgr_contract_graph.","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_load_streetnet.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Load a street network previously saved with dodgr_save_streetnet. — dodgr_load_streetnet","text":"","code":"dodgr_load_streetnet(filename)"},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_load_streetnet.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Load a street network previously saved with dodgr_save_streetnet. — dodgr_load_streetnet","text":"filename Name (optional full path) file loaded.","code":""},{"path":[]},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_load_streetnet.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Load a street network previously saved with dodgr_save_streetnet. — dodgr_load_streetnet","text":"","code":"net <- weight_streetnet (hampi) f <- file.path (tempdir (), \"streetnet.Rds\") dodgr_save_streetnet (net, f) clear_dodgr_cache () # rm cached objects from tempdir # at some later time, or in a new R session: net <- dodgr_load_streetnet (f)"},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_paths.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate lists of pair-wise shortest paths between points. — dodgr_paths","title":"Calculate lists of pair-wise shortest paths between points. — dodgr_paths","text":"Calculate lists pair-wise shortest paths points.","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_paths.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate lists of pair-wise shortest paths between points. — dodgr_paths","text":"","code":"dodgr_paths(   graph,   from,   to,   vertices = TRUE,   pairwise = FALSE,   heap = \"BHeap\",   quiet = TRUE )"},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_paths.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate lists of pair-wise shortest paths between points. — dodgr_paths","text":"graph data.frame equivalent object representing network graph (see Details) Vector matrix points route paths calculated (see Details) Vector matrix points route paths calculated (see Details) vertices TRUE, return lists lists vertices path, otherwise return corresponding lists edge numbers graph. pairwise TRUE, calculate paths ordered pairs . case, must length, output contain paths -th members , thus also length. heap Type heap use priority queue. Options include Fibonacci Heap (default; FHeap), Binary Heap (BHeap), Radix, Trinomial Heap (TriHeap), Extended Trinomial Heap (TriHeapExt, 2-3 Heap (Heap23). quiet FALSE, display progress messages screen.","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_paths.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate lists of pair-wise shortest paths between points. — dodgr_paths","text":"List list paths tracing connections nodes x <- dodgr_paths (graph, , ), path [] [j] x [[]] [[j]]. individual path vector integers indexing rows graph vertices = FALSE, rows dodgr_vertices (graph) vertices = TRUE.","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_paths.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Calculate lists of pair-wise shortest paths between points. — dodgr_paths","text":"graph must minimally contain four columns , , dist. additional column named weight wt present, shortest paths calculated according values specified column; otherwise according dist values. Either way, final distances points calculated according values dist. , paths pair points calculated according minimal total sum weight values (present), reported distances total sums dist values. columns graph may either single columns numeric character values specifying numbers names graph vertices, combinations two columns specifying geographical (longitude latitude) coordinates. latter case, almost sensible combination names accepted (example, fromx, fromy, from_x, from_y, fr_lat, fr_lon.) values can either two-column matrices equivalent longitude latitude coordinates, else single columns precisely matching node numbers names given graph$graph$. missing, pairwise distances calculated points specified . neither specified, pairwise distances calculated nodes graph.","code":""},{"path":[]},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_paths.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate lists of pair-wise shortest paths between points. — dodgr_paths","text":"","code":"graph <- weight_streetnet (hampi) from <- sample (graph$from_id, size = 100) to <- sample (graph$to_id, size = 50) dp <- dodgr_paths (graph, from = from, to = to) # dp is a list with 100 items, and each of those 100 items has 30 items, each # of which is a single path listing all vertiex IDs as taken from `graph`.  # it is also possible to calculate paths between pairwise start and end # points from <- sample (graph$from_id, size = 5) to <- sample (graph$to_id, size = 5) dp <- dodgr_paths (graph, from = from, to = to, pairwise = TRUE) # dp is a list of 5 items, each of which just has a single path between each # pairwise from and to point."},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_sample.html","id":null,"dir":"Reference","previous_headings":"","what":"Sample a random but connected sub-component of a graph — dodgr_sample","title":"Sample a random but connected sub-component of a graph — dodgr_sample","text":"Sample random connected sub-component graph","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_sample.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sample a random but connected sub-component of a graph — dodgr_sample","text":"","code":"dodgr_sample(graph, nverts = 1000)"},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_sample.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sample a random but connected sub-component of a graph — dodgr_sample","text":"graph flat table graph edges. Must contain columns labelled , start stop. May also contain similarly labelled columns spatial coordinates (example from_x) stop_lon). nverts Number vertices sample","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_sample.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sample a random but connected sub-component of a graph — dodgr_sample","text":"connected sub-component graph","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_sample.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Sample a random but connected sub-component of a graph — dodgr_sample","text":"Graphs may occasionally nverts + 1 vertices, rather requested nverts.","code":""},{"path":[]},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_sample.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Sample a random but connected sub-component of a graph — dodgr_sample","text":"","code":"graph <- weight_streetnet (hampi) nrow (graph) # 5,742 #> [1] 6813 graph <- dodgr_sample (graph, nverts = 200) nrow (graph) # generally around 400 edges #> [1] 399 nrow (dodgr_vertices (graph)) # 200 #> [1] 200"},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_save_streetnet.html","id":null,"dir":"Reference","previous_headings":"","what":"Save a weighted streetnet to a local file — dodgr_save_streetnet","title":"Save a weighted streetnet to a local file — dodgr_save_streetnet","text":"weight_streetnet function returns single data.frame object, processing also relies couple cached lookup-tables match edges data.frame objects original input data. automatically calculates caches contracted version graph, enable rapid conversion contracted uncontracted forms. function saves items single .Rds file, result weight_streetnet call can rapidly loaded workspace subsequent sessions, rather re-calculating entire weighted network.","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_save_streetnet.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Save a weighted streetnet to a local file — dodgr_save_streetnet","text":"","code":"dodgr_save_streetnet(net, filename = NULL)"},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_save_streetnet.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Save a weighted streetnet to a local file — dodgr_save_streetnet","text":"net data.frame equivalent object representing weighted network graph. filename Name optional full path file save input net. extension .Rds automatically appended, unless specified otherwise.","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_save_streetnet.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Save a weighted streetnet to a local file — dodgr_save_streetnet","text":"may take time dodgr_cache_off called. contracted version graph also saved, must calculated previously automatically cached.","code":""},{"path":[]},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_save_streetnet.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Save a weighted streetnet to a local file — dodgr_save_streetnet","text":"","code":"net <- weight_streetnet (hampi) f <- file.path (tempdir (), \"streetnet.Rds\") dodgr_save_streetnet (net, f) clear_dodgr_cache () # rm cached objects from tempdir # at some later time, or in a new R session: net <- dodgr_load_streetnet (f)"},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_sflines_to_poly.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert sf LINESTRING objects to POLYGON objects representing all fundamental cycles within the LINESTRING objects. — dodgr_sflines_to_poly","title":"Convert sf LINESTRING objects to POLYGON objects representing all fundamental cycles within the LINESTRING objects. — dodgr_sflines_to_poly","text":"Convert sf LINESTRING objects POLYGON objects representing fundamental cycles within LINESTRING objects.","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_sflines_to_poly.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert sf LINESTRING objects to POLYGON objects representing all fundamental cycles within the LINESTRING objects. — dodgr_sflines_to_poly","text":"","code":"dodgr_sflines_to_poly(sflines, graph_max_size = 10000, expand = 0.05)"},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_sflines_to_poly.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert sf LINESTRING objects to POLYGON objects representing all fundamental cycles within the LINESTRING objects. — dodgr_sflines_to_poly","text":"sflines sf LINESTRING object representing network. graph_max_size Maximum size submitted internal C++ routines single chunk. Warning: Increasing may lead computer meltdown! expand large graphs must broken chunks, factor determines relative overlap chunks ensure cycles captured. (value need modified special cases.)","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_sflines_to_poly.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert sf LINESTRING objects to POLYGON objects representing all fundamental cycles within the LINESTRING objects. — dodgr_sflines_to_poly","text":"sf::sfc collection POLYGON objects.","code":""},{"path":[]},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_streetnet.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract a street network in sf-format for a given location. — dodgr_streetnet","title":"Extract a street network in sf-format for a given location. — dodgr_streetnet","text":"Use osmdata package extract street network given location. routing given set points (passed pts), bbox argument may omitted, case bounding box constructed expanding range pts relative amount expand.","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_streetnet.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract a street network in sf-format for a given location. — dodgr_streetnet","text":"","code":"dodgr_streetnet(bbox, pts = NULL, expand = 0.05, quiet = TRUE)"},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_streetnet.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract a street network in sf-format for a given location. — dodgr_streetnet","text":"bbox Bounding box vector matrix coordinates, location name. Passed osmdata::getbb. pts List points presumably containing spatial coordinates expand Relative factor street network extend beyond limits defined pts (bbox given). quiet FALSE, display progress messages","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_streetnet.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract a street network in sf-format for a given location. — dodgr_streetnet","text":"Simple Features (sf) object coordinates lines street network.","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_streetnet.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Extract a street network in sf-format for a given location. — dodgr_streetnet","text":"Calls function may return \"General overpass server error\" note \"Query timed .\" overpass served used access data sophisticated queueing system prioritises requests likely require little time. timeout errors can thus generally circumvented changing \"timeout\" options HTTP requests, rather interpreted indicate request large, may need refined, somehow broken smaller queries.","code":""},{"path":[]},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_streetnet.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract a street network in sf-format for a given location. — dodgr_streetnet","text":"","code":"if (FALSE) { # \\dontrun{ streetnet <- dodgr_streetnet (\"hampi india\", expand = 0) # convert to form needed for `dodgr` functions: graph <- weight_streetnet (streetnet) nrow (graph) # around 5,900 edges # Alternative ways of extracting street networks by using a small selection # of graph vertices to define bounding box: verts <- dodgr_vertices (graph) verts <- verts [sample (nrow (verts), size = 200), ] streetnet <- dodgr_streetnet (pts = verts, expand = 0) graph <- weight_streetnet (streetnet) nrow (graph) # This will generally have many more rows because most street networks # include streets that extend considerably beyond the specified bounding box.  # bbox can also be a polygon: bb <- osmdata::getbb (\"gent belgium\") # rectangular bbox nrow (dodgr_streetnet (bbox = bb)) # around 30,000 bb <- osmdata::getbb (\"gent belgium\", format_out = \"polygon\") nrow (dodgr_streetnet (bbox = bb)) # around 17,000 # The latter has fewer rows because only edges within polygon are returned  # Example with access restrictions bbox <- c (-122.2935, 47.62663, -122.28, 47.63289) x <- dodgr_streetnet_sc (bbox) net <- weight_streetnet (x, keep_cols = \"access\", turn_penalty = TRUE) # has many streets with \"access\" = \"private\"; these can be removed like this: net2 <- net [which (!net$access != \"private\"), ] # or modified in some other way such as strongly penalizing use of those # streets: index <- which (net$access == \"private\") net$time_weighted [index] <- net$time_weighted [index] * 100 } # }"},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_streetnet_geodesic.html","id":null,"dir":"Reference","previous_headings":"","what":"Force weight_streetnet to use geodesic distances. — dodgr_streetnet_geodesic","title":"Force weight_streetnet to use geodesic distances. — dodgr_streetnet_geodesic","text":"Distances default Mapbox \"cheap\" distances maximal network distances < 100km, otherwise Haversine distances. Calling function forces calls weight_streetnet point use geodesic distances. computationally expensive calculate, weighting networks likely take time.","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_streetnet_geodesic.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Force weight_streetnet to use geodesic distances. — dodgr_streetnet_geodesic","text":"","code":"dodgr_streetnet_geodesic(unset = FALSE)"},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_streetnet_geodesic.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Force weight_streetnet to use geodesic distances. — dodgr_streetnet_geodesic","text":"unset Calling function unset = TRUE reverts distance calculations described , rather geodesic.","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_streetnet_geodesic.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Force weight_streetnet to use geodesic distances. — dodgr_streetnet_geodesic","text":"Nothing; function called side-effect setting distance calculations geodesic.","code":""},{"path":[]},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_streetnet_sc.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract a street network in silicate-format for a given location. — dodgr_streetnet_sc","title":"Extract a street network in silicate-format for a given location. — dodgr_streetnet_sc","text":"Use osmdata package extract street network given location return SC-format. routing given set points (passed pts), bbox argument may omitted, case bounding box constructed expanding range pts relative amount expand.","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_streetnet_sc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract a street network in silicate-format for a given location. — dodgr_streetnet_sc","text":"","code":"dodgr_streetnet_sc(bbox, pts = NULL, expand = 0.05, quiet = TRUE)"},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_streetnet_sc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract a street network in silicate-format for a given location. — dodgr_streetnet_sc","text":"bbox Bounding box vector matrix coordinates, location name. Passed osmdata::getbb. pts List points presumably containing spatial coordinates expand Relative factor street network extend beyond limits defined pts (bbox given). quiet FALSE, display progress messages","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_streetnet_sc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract a street network in silicate-format for a given location. — dodgr_streetnet_sc","text":"Simple Features (sf) object coordinates lines street network.","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_streetnet_sc.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Extract a street network in silicate-format for a given location. — dodgr_streetnet_sc","text":"Calls function may return \"General overpass server error\" note \"Query timed .\" overpass served used access data sophisticated queueing system prioritises requests likely require little time. timeout errors can thus generally circumvented changing \"timeout\" options HTTP requests, rather interpreted indicate request large, may need refined, somehow broken smaller queries.","code":""},{"path":[]},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_streetnet_sc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract a street network in silicate-format for a given location. — dodgr_streetnet_sc","text":"","code":"if (FALSE) { # \\dontrun{ streetnet <- dodgr_streetnet (\"hampi india\", expand = 0) # convert to form needed for `dodgr` functions: graph <- weight_streetnet (streetnet) nrow (graph) # around 5,900 edges # Alternative ways of extracting street networks by using a small selection # of graph vertices to define bounding box: verts <- dodgr_vertices (graph) verts <- verts [sample (nrow (verts), size = 200), ] streetnet <- dodgr_streetnet (pts = verts, expand = 0) graph <- weight_streetnet (streetnet) nrow (graph) # This will generally have many more rows because most street networks # include streets that extend considerably beyond the specified bounding box.  # bbox can also be a polygon: bb <- osmdata::getbb (\"gent belgium\") # rectangular bbox nrow (dodgr_streetnet (bbox = bb)) # around 30,000 bb <- osmdata::getbb (\"gent belgium\", format_out = \"polygon\") nrow (dodgr_streetnet (bbox = bb)) # around 17,000 # The latter has fewer rows because only edges within polygon are returned  # Example with access restrictions bbox <- c (-122.2935, 47.62663, -122.28, 47.63289) x <- dodgr_streetnet_sc (bbox) net <- weight_streetnet (x, keep_cols = \"access\", turn_penalty = TRUE) # has many streets with \"access\" = \"private\"; these can be removed like this: net2 <- net [which (!net$access != \"private\"), ] # or modified in some other way such as strongly penalizing use of those # streets: index <- which (net$access == \"private\") net$time_weighted [index] <- net$time_weighted [index] * 100 } # }"},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_times.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate matrix of pair-wise travel times between points. — dodgr_times","title":"Calculate matrix of pair-wise travel times between points. — dodgr_times","text":"Calculate matrix pair-wise travel times points.","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_times.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate matrix of pair-wise travel times between points. — dodgr_times","text":"","code":"dodgr_times(graph, from = NULL, to = NULL, shortest = FALSE, heap = \"BHeap\")"},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_times.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate matrix of pair-wise travel times between points. — dodgr_times","text":"graph data.frame equivalent object representing network graph (see Notes). dodgr street networks, may network derived either sf silicate (\"sc\") data, generated weight_streetnet. columns graph may either single columns numeric character values specifying numbers names graph vertices, combinations two columns specifying geographical (longitude latitude,) coordinates. latter case, almost sensible combination names accepted (example, fromx, fromy, from_x, from_y, fr_lat, fr_lon.) Note longitude latitude values always interpreted 'dodgr' EPSG:4326 / WSG84 coordinates. kinds coordinates first reprojected EPSG:4326 submitting 'dodgr' routines. See information Details. Vector matrix points route distances calculated, specified one following: Single character vector precisely matching node numbers names given graph$graph$. Single vector integer-ish values, case presumed specify indices dodgr_vertices, correspond values '' '' columns graph. See example demonstration. Matrix equivalent longitude latitude coordinates, case matched nearest coordinates '' '' points graph. Vector matrix points route distances calculated. NULL, pairwise distances calculated points nodes graph. NULL, pairwise distances calculated nodes graph. shortest FALSE, calculate distances along fastest rather shortest routes. street networks produced weight_streetnet, distances may also calculated along fastest routes shortest = FALSE option. Graphs must case columns time time_weighted. Note fastest routes approximate derived sf-format data generated osmdata function osmdata_sf(), much accurate derived sc-format data generated osmdata_sc(). See weight_streetnet details. heap Type heap use priority queue. Options include Fibonacci Heap (default; FHeap), Binary Heap (BHeap), Trinomial Heap (TriHeap), Extended Trinomial Heap (TriHeapExt, 2-3 Heap (Heap23`).","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_times.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate matrix of pair-wise travel times between points. — dodgr_times","text":"square matrix distances nodes","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_times.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate matrix of pair-wise travel times between points. — dodgr_times","text":"graph must minimally contain three columns , , dist. additional column named weight wt present, shortest paths calculated according values specified column; otherwise according dist values. Either way, final distances points calculated default according values dist. , paths pair points calculated according minimal total sum weight values (present), reported distances total sums dist values.","code":""},{"path":[]},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_times.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate matrix of pair-wise travel times between points. — dodgr_times","text":"","code":"# A simple graph graph <- data.frame (     from = c (\"A\", \"B\", \"B\", \"B\", \"C\", \"C\", \"D\", \"D\"),     to = c (\"B\", \"A\", \"C\", \"D\", \"B\", \"D\", \"C\", \"A\"),     d = c (1, 2, 1, 3, 2, 1, 2, 1) ) dodgr_dists (graph) #>   A B C D #> A 0 1 2 3 #> B 2 0 1 2 #> C 2 2 0 1 #> D 1 2 2 0  # Example of \"from\" and \"to\" as integer-ish values, in which case they are # interpreted to index into \"dodgr_vertices()\": graph <- data.frame (     from = c (1, 3, 2, 2, 3, 3, 4, 4),     to = c (2, 1, 3, 4, 2, 4, 3, 1),     d = c (1, 2, 1, 3, 2, 1, 2, 1) ) dodgr_dists (graph, from = 1, to = 2) #>   3 #> 1 2 # That then gives distance from \"1\" to \"3\" because the vertices are built # sequentially along \"graph$from\": dodgr_vertices (graph) #>   id n #> 1  1 0 #> 2  3 1 #> 3  2 2 #> 7  4 3 # And vertex$id [2] is \"3\"  # A larger example from the included [hampi()] data. graph <- weight_streetnet (hampi) from <- sample (graph$from_id, size = 100) to <- sample (graph$to_id, size = 50) d <- dodgr_dists (graph, from = from, to = to) # d is a 100-by-50 matrix of distances between `from` and `to`  if (FALSE) { # \\dontrun{ # a more complex street network example, thanks to @chrijo; see # https://github.com/UrbanAnalyst/dodgr/issues/47  xy <- rbind (     c (7.005994, 51.45774), # limbeckerplatz 1 essen germany     c (7.012874, 51.45041) ) # hauptbahnhof essen germany xy <- data.frame (lon = xy [, 1], lat = xy [, 2]) essen <- dodgr_streetnet (pts = xy, expand = 0.2, quiet = FALSE) graph <- weight_streetnet (essen, wt_profile = \"foot\") d <- dodgr_dists (graph, from = xy, to = xy) # First reason why this does not work is because the graph has multiple, # disconnected components. table (graph$component) # reduce to largest connected component, which is always number 1 graph <- graph [which (graph$component == 1), ] d <- dodgr_dists (graph, from = xy, to = xy) # should work, but even then note that table (essen$level) # There are parts of the network on different building levels (because of # shopping malls and the like). These may or may not be connected, so it may # be necessary to filter out particular levels index <- which (!(essen$level == \"-1\" | essen$level == \"1\")) # for example library (sf) # needed for following sub-select operation essen <- essen [index, ] graph <- weight_streetnet (essen, wt_profile = \"foot\") graph <- graph [which (graph$component == 1), ] d <- dodgr_dists (graph, from = xy, to = xy) } # }"},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_to_igraph.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert a dodgr graph to an igraph. — dodgr_to_igraph","title":"Convert a dodgr graph to an igraph. — dodgr_to_igraph","text":"Convert dodgr graph igraph.","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_to_igraph.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert a dodgr graph to an igraph. — dodgr_to_igraph","text":"","code":"dodgr_to_igraph(graph, weight_column = \"d\")"},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_to_igraph.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert a dodgr graph to an igraph. — dodgr_to_igraph","text":"graph dodgr graph weight_column column dodgr network use edge weights igraph representation.","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_to_igraph.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert a dodgr graph to an igraph. — dodgr_to_igraph","text":"igraph equivalent input. Note dual-weighted graph.","code":""},{"path":[]},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_to_igraph.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert a dodgr graph to an igraph. — dodgr_to_igraph","text":"","code":"graph <- weight_streetnet (hampi) graphi <- dodgr_to_igraph (graph)"},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_to_sf.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert a dodgr graph into an equivalent sf object. — dodgr_to_sf","title":"Convert a dodgr graph into an equivalent sf object. — dodgr_to_sf","text":"Works aggregating edges LINESTRING objects representing longest sequences junction nodes. resultant objects generally contain LINESTRING objects original sf object, former bisected every junction point.","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_to_sf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert a dodgr graph into an equivalent sf object. — dodgr_to_sf","text":"","code":"dodgr_to_sf(graph)"},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_to_sf.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert a dodgr graph into an equivalent sf object. — dodgr_to_sf","text":"graph dodgr graph","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_to_sf.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert a dodgr graph into an equivalent sf object. — dodgr_to_sf","text":"Equivalent object class sf.","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_to_sf.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Convert a dodgr graph into an equivalent sf object. — dodgr_to_sf","text":"Requires sf package installed.","code":""},{"path":[]},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_to_sf.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert a dodgr graph into an equivalent sf object. — dodgr_to_sf","text":"","code":"hw <- weight_streetnet (hampi) nrow (hw) # 5,729 edges #> [1] 6813 xy <- dodgr_to_sf (hw) dim (xy) # 764 edges; 14 attributes #> [1] 744  17"},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_to_sfc.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert a dodgr graph into an equivalent sf::sfc object. — dodgr_to_sfc","title":"Convert a dodgr graph into an equivalent sf::sfc object. — dodgr_to_sfc","text":"Convert dodgr graph list composed two objects: dat, data.frame; geometry, sfc object (sf) package. Works aggregating edges LINESTRING objects representing longest sequences junction nodes. resultant objects generally contain LINESTRING objects original sf object, former bisected every junction point.","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_to_sfc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert a dodgr graph into an equivalent sf::sfc object. — dodgr_to_sfc","text":"","code":"dodgr_to_sfc(graph)"},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_to_sfc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert a dodgr graph into an equivalent sf::sfc object. — dodgr_to_sfc","text":"graph dodgr graph","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_to_sfc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert a dodgr graph into an equivalent sf::sfc object. — dodgr_to_sfc","text":"list containing (1) data.frame data associated sf geometries; (ii) Simple Features Collection (sfc) list LINESTRING objects.","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_to_sfc.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Convert a dodgr graph into an equivalent sf::sfc object. — dodgr_to_sfc","text":"output function corresponds edges obtained dodgr_contract_graph. function require sf package installed; corresponding function creates full sf object - dodgr_to_sf requires sf installed.","code":""},{"path":[]},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_to_sfc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert a dodgr graph into an equivalent sf::sfc object. — dodgr_to_sfc","text":"","code":"hw <- weight_streetnet (hampi) nrow (hw) #> [1] 6813 xy <- dodgr_to_sfc (hw) dim (hw) # 5.845 edges #> [1] 6813   16 length (xy$geometry) # more linestrings aggregated from those edges #> [1] 744 nrow (hampi) # than the 191 linestrings in original sf object #> [1] 236 dim (xy$dat) # same number of rows as there are geometries #> [1] 744  16 # The dodgr_to_sf function then just implements this final conversion: # sf::st_sf (xy$dat, geometry = xy$geometry, crs = 4326)"},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_to_tidygraph.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert a dodgr graph to an tidygraph. — dodgr_to_tidygraph","title":"Convert a dodgr graph to an tidygraph. — dodgr_to_tidygraph","text":"Convert dodgr graph tidygraph.","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_to_tidygraph.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert a dodgr graph to an tidygraph. — dodgr_to_tidygraph","text":"","code":"dodgr_to_tidygraph(graph)"},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_to_tidygraph.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert a dodgr graph to an tidygraph. — dodgr_to_tidygraph","text":"graph dodgr graph","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_to_tidygraph.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert a dodgr graph to an tidygraph. — dodgr_to_tidygraph","text":"tidygraph equivalent input","code":""},{"path":[]},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_to_tidygraph.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert a dodgr graph to an tidygraph. — dodgr_to_tidygraph","text":"","code":"graph <- weight_streetnet (hampi) grapht <- dodgr_to_tidygraph (graph) #> Loading required namespace: tidygraph"},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_uncontract_graph.html","id":null,"dir":"Reference","previous_headings":"","what":"Re-expand a contracted graph. — dodgr_uncontract_graph","title":"Re-expand a contracted graph. — dodgr_uncontract_graph","text":"Revert contracted graph created dodgr_contract_graph back full, uncontracted version. function mostly used side effect mapping new columns inserted contracted graph back original graph, demonstrated example.","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_uncontract_graph.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Re-expand a contracted graph. — dodgr_uncontract_graph","text":"","code":"dodgr_uncontract_graph(graph)"},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_uncontract_graph.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Re-expand a contracted graph. — dodgr_uncontract_graph","text":"graph contracted graph created dodgr_contract_graph.","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_uncontract_graph.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Re-expand a contracted graph. — dodgr_uncontract_graph","text":"single data.frame representing equivalent original, uncontracted graph.","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_uncontract_graph.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Re-expand a contracted graph. — dodgr_uncontract_graph","text":"Note function generally recover original graphs submitted dodgr_contract_graph. Specifically, sequence dodgr_contract_graph(graph) |> dodgr_uncontract_graph() generally produce graph fewer edges original. graphs may multiple paths given pair points. Contraction reduce single path shortest weighted distance (time), uncontraction restore single edge shortest weighted distance, original edges may longer weighted distances.","code":""},{"path":[]},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_uncontract_graph.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Re-expand a contracted graph. — dodgr_uncontract_graph","text":"","code":"graph0 <- weight_streetnet (hampi) nrow (graph0) # 6,813 #> [1] 6813 graph1 <- dodgr_contract_graph (graph0) nrow (graph1) # 760 #> [1] 744 graph2 <- dodgr_uncontract_graph (graph1) nrow (graph2) # 6,813 #> [1] 6813  # Insert new data on to the contracted graph and uncontract it: graph1$new_col <- runif (nrow (graph1)) graph3 <- dodgr_uncontract_graph (graph1) # graph3 is then the uncontracted graph which includes \"new_col\" as well dim (graph0) #> [1] 6813   16 dim (graph3) #> [1] 6813   17"},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_vertices.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract vertices of graph, including spatial coordinates if included. — dodgr_vertices","title":"Extract vertices of graph, including spatial coordinates if included. — dodgr_vertices","text":"Extract vertices graph, including spatial coordinates included.","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_vertices.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract vertices of graph, including spatial coordinates if included. — dodgr_vertices","text":"","code":"dodgr_vertices(graph)"},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_vertices.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract vertices of graph, including spatial coordinates if included. — dodgr_vertices","text":"graph flat table graph edges. Must contain columns labelled , start stop. May also contain similarly labelled columns spatial coordinates (example from_x) stop_lon).","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_vertices.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract vertices of graph, including spatial coordinates if included. — dodgr_vertices","text":"data.frame vertices unique numbers (n).","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_vertices.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Extract vertices of graph, including spatial coordinates if included. — dodgr_vertices","text":"Values n 0-indexed","code":""},{"path":[]},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/dodgr_vertices.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract vertices of graph, including spatial coordinates if included. — dodgr_vertices","text":"","code":"graph <- weight_streetnet (hampi) v <- dodgr_vertices (graph)"},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/estimate_centrality_threshold.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimate a value for the 'dist_threshold' parameter of the dodgr_centrality function. — estimate_centrality_threshold","title":"Estimate a value for the 'dist_threshold' parameter of the dodgr_centrality function. — estimate_centrality_threshold","text":"Providing distance thresholds function generally provides considerably speed gains, results approximations centrality. function enables determination values 'dist_threshold' corresponding specific degrees accuracy.","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/estimate_centrality_threshold.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimate a value for the 'dist_threshold' parameter of the dodgr_centrality function. — estimate_centrality_threshold","text":"","code":"estimate_centrality_threshold(graph, tolerance = 0.001)"},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/estimate_centrality_threshold.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimate a value for the 'dist_threshold' parameter of the dodgr_centrality function. — estimate_centrality_threshold","text":"graph 'data.frame' equivalent object representing network graph (see Details) tolerance Desired maximal degree inaccuracy centrality estimates values accurate within amount, subject constant scaling factor. Note threshold values increase non-linearly decreasing values 'tolerance'","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/estimate_centrality_threshold.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Estimate a value for the 'dist_threshold' parameter of the dodgr_centrality function. — estimate_centrality_threshold","text":"single value 'dist_threshold' giving required tolerance.","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/estimate_centrality_threshold.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Estimate a value for the 'dist_threshold' parameter of the dodgr_centrality function. — estimate_centrality_threshold","text":"function may take time execute. running, displays ongoing information screen estimated values 'dist_threshold' associated errors. Thresholds progressively increased error reduced specified tolerance.","code":""},{"path":[]},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/estimate_centrality_time.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimate time required for a planned centrality calculation. — estimate_centrality_time","title":"Estimate time required for a planned centrality calculation. — estimate_centrality_time","text":"'dodgr' centrality functions designed applied potentially large graphs, may take considerable time execute. helper function estimates long centrality function may take given graph given value 'dist_threshold' estimated via estimate_centrality_threshold function.","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/estimate_centrality_time.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimate time required for a planned centrality calculation. — estimate_centrality_time","text":"","code":"estimate_centrality_time(   graph,   contract = TRUE,   edges = TRUE,   dist_threshold = NULL,   heap = \"BHeap\" )"},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/estimate_centrality_time.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimate time required for a planned centrality calculation. — estimate_centrality_time","text":"graph 'data.frame' equivalent object representing network graph (see Details) contract 'TRUE', centrality calculated contracted graph mapping back original full graph. Note street networks, particular obtained osmdata package, vertex placement effectively arbitrary except junctions; centrality graphs calculated latter points, thus 'contract' always 'TRUE'. edges 'TRUE', centrality calculated graph edges, returning input 'graph' additional 'centrality' column; otherwise centrality calculated vertices, returning equivalent 'dodgr_vertices(graph)', additional vertex-based 'centrality' column. dist_threshold 'NULL', calculate centrality point specified threshold. Setting values result approximate estimates centrality, yet considerable gains computational efficiency. sufficiently large values, approximations accurate within constant multiplier. Appropriate values can established via estimate_centrality_threshold function. heap Type heap use priority queue. Options include Fibonacci Heap (default; 'FHeap'), Binary Heap ('BHeap'), Trinomial Heap ('TriHeap'), Extended Trinomial Heap ('TriHeapExt', 2-3 Heap ('Heap23').","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/estimate_centrality_time.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Estimate time required for a planned centrality calculation. — estimate_centrality_time","text":"estimated calculation time calculating centrality given value 'dist_threshold'","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/estimate_centrality_time.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Estimate time required for a planned centrality calculation. — estimate_centrality_time","text":"function may take time execute. running, displays ongoing information screen estimated values 'dist_threshold' associated errors. Thresholds progressively increased error reduced specified tolerance.","code":""},{"path":[]},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/hampi.html","id":null,"dir":"Reference","previous_headings":"","what":"Sample street network from Hampi, India. — hampi","title":"Sample street network from Hampi, India. — hampi","text":"sample street network township Hampi, Karnataka, India.","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/hampi.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Sample street network from Hampi, India. — hampi","text":"Simple Features sf data.frame containing street network Hampi.","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/hampi.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Sample street network from Hampi, India. — hampi","text":"Can re-created following command, also removes extraneous columns reduce size:","code":""},{"path":[]},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/hampi.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Sample street network from Hampi, India. — hampi","text":"","code":"if (FALSE) { # \\dontrun{ hampi <- dodgr_streetnet (\"hampi india\") cols <- c (\"osm_id\", \"highway\", \"oneway\", \"geometry\") hampi <- hampi [, which (names (hampi) %in% cols)] } # } # this 'sf data.frame' can be converted to a 'dodgr' network with net <- weight_streetnet (hampi, wt_profile = \"foot\")"},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/igraph_to_dodgr.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert a igraph network to an equivalent dodgr representation. — igraph_to_dodgr","title":"Convert a igraph network to an equivalent dodgr representation. — igraph_to_dodgr","text":"Convert igraph network equivalent dodgr representation.","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/igraph_to_dodgr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert a igraph network to an equivalent dodgr representation. — igraph_to_dodgr","text":"","code":"igraph_to_dodgr(graph)"},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/igraph_to_dodgr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert a igraph network to an equivalent dodgr representation. — igraph_to_dodgr","text":"graph igraph network","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/igraph_to_dodgr.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert a igraph network to an equivalent dodgr representation. — igraph_to_dodgr","text":"dodgr equivalent input.","code":""},{"path":[]},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/igraph_to_dodgr.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert a igraph network to an equivalent dodgr representation. — igraph_to_dodgr","text":"","code":"graph <- weight_streetnet (hampi) graphi <- dodgr_to_igraph (graph) graph2 <- igraph_to_dodgr (graphi) identical (graph2, graph) # FALSE #> [1] FALSE"},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/match_points_to_graph.html","id":null,"dir":"Reference","previous_headings":"","what":"Alias for match_pts_to_graph — match_points_to_graph","title":"Alias for match_pts_to_graph — match_points_to_graph","text":"Match spatial points edges spatial graph, finding edge closest perpendicular intersection. NOTE: Intersections calculated geometrically, presume planar geometry. users projected geometrical data, within dodgr_streetnet object, ensure either: () Data span sufficiently small area errors presuming planar geometry may ignored; (ii) Data re-projected equivalent planar geometry prior calling routine.","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/match_points_to_graph.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Alias for match_pts_to_graph — match_points_to_graph","text":"","code":"match_points_to_graph(graph, xy, connected = FALSE, distances = FALSE)"},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/match_points_to_graph.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Alias for match_pts_to_graph — match_points_to_graph","text":"graph dodgr graph spatial coordinates, dodgr_streetnet object. xy coordinates points matched vertices, either matrix sf-formatted data.frame. connected points matched (largest) connected component graph? FALSE points used dodgr routing routine (dodgr_dists, dodgr_paths, dodgr_flows_aggregate), results may returned points part connected component. hand, forcing part connected component may decrease spatial accuracy matching. distances TRUE, return 'data.frame' object 'index' column described return value; additional columns perpendicular distance nearest edge graph, coordinates points intersection. See description return value details.","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/match_points_to_graph.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Alias for match_pts_to_graph — match_points_to_graph","text":"distances = FALSE (default), vector index matching xy coordinates nearest edges. bi-directional edges, one match returned, user identify suitably process matching edge pairs. 'distances = TRUE', 'data.frame' four columns: \"index\" index closest edges \"graph\", described . \"d_signed\" perpendicular distance ech point nearest edge, negative distances denoting points left edges, positive distances denoting points right. Distances zero denote points lying precisely line edge (potentially including cases nearest point bisection lies beyond actual edge). \"x\" x-coordinate point intersection. \"y\" y-coordinate point intersection.","code":""},{"path":[]},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/match_points_to_graph.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Alias for match_pts_to_graph — match_points_to_graph","text":"","code":"graph <- weight_streetnet (hampi, wt_profile = \"foot\") # Then generate some random points to match to graph verts <- dodgr_vertices (graph) npts <- 10 xy <- data.frame (     x = min (verts$x) + runif (npts) * diff (range (verts$x)),     y = min (verts$y) + runif (npts) * diff (range (verts$y)) ) edges <- match_pts_to_graph (graph, xy) graph [edges, ] # The edges of the graph closest to `xy` #>      geom_num edge_id    from_id from_lon from_lat      to_id   to_lon   to_lat #> 4633      133    4633 2398957752 76.46191 15.32219  338904911 76.46199 15.32206 #> 3395       89    3395 2588119056 76.42341 15.31717 2588146107 76.42349 15.31746 #> 1317       36    1317 8615359666 76.45910 15.33583 8615359667 76.45873 15.33588 #> 6201      203    6201 7769271419 76.37263 15.34499 7769190961 76.38203 15.34708 #> 4443      122    4443 8632960966 76.47228 15.32009 8632960965 76.47220 15.31997 #> 3421       89    3421 2588146013 76.42587 15.31860 7793366194 76.42601 15.31860 #> 3433       89    3433 2588146085 76.42675 15.31926 2588146132 76.42707 15.31947 #> 6253      203    6253 6597300510 76.42343 15.35101 1388482473 76.42580 15.35076 #> 6239      203    6239 1388482647 76.40387 15.35230 1204772675 76.40457 15.35226 #> 6247      203    6247 1204772780 76.40951 15.35236 1204772868 76.41809 15.35157 #>               d d_weighted      highway    way_id component      time #> 4633   16.34059   27.23432    secondary 327102382         1  11.76523 #> 3395   33.13677   41.42096 unclassified 252786290         1  23.85847 #> 1317   39.77370   39.77370         path  84006211         1  28.63707 #> 6201 1034.09976 2068.19951      primary 835018468         2 744.55182 #> 4443   15.93157   15.93157         path 266144436         1  11.47073 #> 3421   15.13601   18.92001 unclassified 252786290         1  10.89792 #> 3433   41.57680   51.97100 unclassified 252786290         1  29.93530 #> 6253  255.05491  510.10982      primary 835018468         2 183.63954 #> 6239   75.60595  151.21190      primary 835018468         2  54.43628 #> 6247  924.25080 1848.50160      primary 835018468         2 665.46058 #>      time_weighted #> 4633      19.60871 #> 3395      29.82309 #> 1317      28.63707 #> 6201    1489.10365 #> 4443      11.47073 #> 3421      13.62241 #> 3433      37.41912 #> 6253     367.27907 #> 6239     108.87257 #> 6247    1330.92115"},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/match_points_to_verts.html","id":null,"dir":"Reference","previous_headings":"","what":"Alias for match_pts_to_verts — match_points_to_verts","title":"Alias for match_pts_to_verts — match_points_to_verts","text":"match_pts_to_graph function matches points nearest edge based geometric intersections; function matches nearest vertex based point--point distances.","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/match_points_to_verts.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Alias for match_pts_to_verts — match_points_to_verts","text":"","code":"match_points_to_verts(verts, xy, connected = FALSE)"},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/match_points_to_verts.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Alias for match_pts_to_verts — match_points_to_verts","text":"verts data.frame vertices obtained dodgr_vertices(graph). xy coordinates points matched vertices, either matrix sf-formatted data.frame. connected points matched (largest) connected component graph? FALSE points used dodgr routing routine (dodgr_dists, dodgr_paths, dodgr_flows_aggregate), results may returned points part connected component. hand, forcing part connected component may decrease spatial accuracy matching.","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/match_points_to_verts.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Alias for match_pts_to_verts — match_points_to_verts","text":"vector index verts","code":""},{"path":[]},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/match_points_to_verts.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Alias for match_pts_to_verts — match_points_to_verts","text":"","code":"net <- weight_streetnet (hampi, wt_profile = \"foot\") verts <- dodgr_vertices (net) # Then generate some random points to match to graph npts <- 10 xy <- data.frame (     x = min (verts$x) + runif (npts) * diff (range (verts$x)),     y = min (verts$y) + runif (npts) * diff (range (verts$y)) ) pts <- match_pts_to_verts (verts, xy) pts # an index into verts #>  [1] 3051  389  248 1704 1431 3075 1182 1800   30 2325 pts <- verts$id [pts] pts # names of those vertices #>  [1] \"6025347259\" \"571423425\"  \"339574181\"  \"2588119056\" \"1398747993\" #>  [6] \"1204772780\" \"1376769213\" \"2588155744\" \"313796397\"  \"2398957680\""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/match_pts_to_graph.html","id":null,"dir":"Reference","previous_headings":"","what":"Match spatial points to the edges of a spatial graph. — match_pts_to_graph","title":"Match spatial points to the edges of a spatial graph. — match_pts_to_graph","text":"Match spatial points edges spatial graph, finding edge closest perpendicular intersection. NOTE: Intersections calculated geometrically, presume planar geometry. users projected geometrical data, within dodgr_streetnet object, ensure either: () Data span sufficiently small area errors presuming planar geometry may ignored; (ii) Data re-projected equivalent planar geometry prior calling routine.","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/match_pts_to_graph.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Match spatial points to the edges of a spatial graph. — match_pts_to_graph","text":"","code":"match_pts_to_graph(graph, xy, connected = FALSE, distances = FALSE)"},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/match_pts_to_graph.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Match spatial points to the edges of a spatial graph. — match_pts_to_graph","text":"graph dodgr graph spatial coordinates, dodgr_streetnet object. xy coordinates points matched vertices, either matrix sf-formatted data.frame. connected points matched (largest) connected component graph? FALSE points used dodgr routing routine (dodgr_dists, dodgr_paths, dodgr_flows_aggregate), results may returned points part connected component. hand, forcing part connected component may decrease spatial accuracy matching. distances TRUE, return 'data.frame' object 'index' column described return value; additional columns perpendicular distance nearest edge graph, coordinates points intersection. See description return value details.","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/match_pts_to_graph.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Match spatial points to the edges of a spatial graph. — match_pts_to_graph","text":"distances = FALSE (default), vector index matching xy coordinates nearest edges. bi-directional edges, one match returned, user identify suitably process matching edge pairs. 'distances = TRUE', 'data.frame' four columns: \"index\" index closest edges \"graph\", described . \"d_signed\" perpendicular distance ech point nearest edge, negative distances denoting points left edges, positive distances denoting points right. Distances zero denote points lying precisely line edge (potentially including cases nearest point bisection lies beyond actual edge). \"x\" x-coordinate point intersection. \"y\" y-coordinate point intersection.","code":""},{"path":[]},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/match_pts_to_graph.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Match spatial points to the edges of a spatial graph. — match_pts_to_graph","text":"","code":"graph <- weight_streetnet (hampi, wt_profile = \"foot\") # Then generate some random points to match to graph verts <- dodgr_vertices (graph) npts <- 10 xy <- data.frame (     x = min (verts$x) + runif (npts) * diff (range (verts$x)),     y = min (verts$y) + runif (npts) * diff (range (verts$y)) ) edges <- match_pts_to_graph (graph, xy) graph [edges, ] # The edges of the graph closest to `xy` #>        geom_num edge_id    from_id from_lon from_lat      to_id   to_lon #> 3611         90    3611 7794286100 76.43425 15.32886 7794286099 76.43414 #> 1285         35    1285  571423206 76.48734 15.35598 5351515769 76.48789 #> 6201        203    6201 7769271419 76.37263 15.34499 7769190961 76.38203 #> 6209        203    6209 1388482509 76.38860 15.34745 1204772662 76.38895 #> 6273        203    6273 1388483466 76.43520 15.34951 1204772874 76.43822 #> 6201.1      203    6201 7769271419 76.37263 15.34499 7769190961 76.38203 #> 6303        205    6303 7799710765 76.47804 15.32587 7799710766 76.47809 #> 6201.2      203    6201 7769271419 76.37263 15.34499 7769190961 76.38203 #> 6209.1      203    6209 1388482509 76.38860 15.34745 1204772662 76.38895 #> 5931        184    5931 6161030370 76.46631 15.33329 6161030371 76.46593 #>          to_lat           d d_weighted highway    way_id component       time #> 3611   15.32869   21.903916   23.05675   track 252787544         1  15.770820 #> 1285   15.35570   66.442849  132.88570 primary  53658844         2  47.838851 #> 6201   15.34708 1034.099756 2068.19951 primary 835018468         2 744.551824 #> 6209   15.34748   38.100586   76.20117 primary 835018468         2  27.432422 #> 6273   15.34926  325.065460  650.13092 primary 835018468         2 234.047131 #> 6201.1 15.34708 1034.099756 2068.19951 primary 835018468         2 744.551824 #> 6303   15.32594    9.703626   10.21434   track 835627549         3   6.986611 #> 6201.2 15.34708 1034.099756 2068.19951 primary 835018468         2 744.551824 #> 6209.1 15.34748   38.100586   76.20117 primary 835018468         2  27.432422 #> 5931   15.33319   42.134080   42.13408    path 657845270         1  30.336538 #>        time_weighted #> 3611       16.600863 #> 1285       95.677702 #> 6201     1489.103648 #> 6209       54.864844 #> 6273      468.094263 #> 6201.1   1489.103648 #> 6303        7.354327 #> 6201.2   1489.103648 #> 6209.1     54.864844 #> 5931       30.336538"},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/match_pts_to_verts.html","id":null,"dir":"Reference","previous_headings":"","what":"Match spatial points to the vertices of a spatial graph. — match_pts_to_verts","title":"Match spatial points to the vertices of a spatial graph. — match_pts_to_verts","text":"match_pts_to_graph function matches points nearest edge based geometric intersections; function matches nearest vertex based point--point distances.","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/match_pts_to_verts.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Match spatial points to the vertices of a spatial graph. — match_pts_to_verts","text":"","code":"match_pts_to_verts(verts, xy, connected = FALSE)"},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/match_pts_to_verts.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Match spatial points to the vertices of a spatial graph. — match_pts_to_verts","text":"verts data.frame vertices obtained dodgr_vertices(graph). xy coordinates points matched vertices, either matrix sf-formatted data.frame. connected points matched (largest) connected component graph? FALSE points used dodgr routing routine (dodgr_dists, dodgr_paths, dodgr_flows_aggregate), results may returned points part connected component. hand, forcing part connected component may decrease spatial accuracy matching.","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/match_pts_to_verts.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Match spatial points to the vertices of a spatial graph. — match_pts_to_verts","text":"vector index verts","code":""},{"path":[]},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/match_pts_to_verts.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Match spatial points to the vertices of a spatial graph. — match_pts_to_verts","text":"","code":"net <- weight_streetnet (hampi, wt_profile = \"foot\") verts <- dodgr_vertices (net) # Then generate some random points to match to graph npts <- 10 xy <- data.frame (     x = min (verts$x) + runif (npts) * diff (range (verts$x)),     y = min (verts$y) + runif (npts) * diff (range (verts$y)) ) pts <- match_pts_to_verts (verts, xy) pts # an index into verts #>  [1] 2371  657 2076 2920  426 1220  443 1704 3075 3052 pts <- verts$id [pts] pts # names of those vertices #>  [1] \"338905245\"  \"571423207\"  \"2627452258\" \"1376768773\" \"338512646\"  #>  [6] \"7799711043\" \"676635813\"  \"2588119056\" \"1204772780\" \"7769271419\""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/merge_directed_graph.html","id":null,"dir":"Reference","previous_headings":"","what":"Merge directed edges into equivalent undirected edges. — merge_directed_graph","title":"Merge directed edges into equivalent undirected edges. — merge_directed_graph","text":"Merge directed edges equivalent undirected values aggregating across directions. function primarily intended aid visualisation directed graphs, particularly visualising results dodgr_flows_aggregate dodgr_flows_disperse functions, return columns aggregated flows directed along edge graph.","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/merge_directed_graph.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Merge directed edges into equivalent undirected edges. — merge_directed_graph","text":"","code":"merge_directed_graph(graph, col_names = c(\"flow\"))"},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/merge_directed_graph.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Merge directed edges into equivalent undirected edges. — merge_directed_graph","text":"graph undirected graph directed edges input graph merged aggregation yield single, undirected edge pair vertices. col_names Names columns merged aggregation. Values columns resultant undirected graph aggregated directed values.","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/merge_directed_graph.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Merge directed edges into equivalent undirected edges. — merge_directed_graph","text":"equivalent graph directed edges reduced single, undirected edges, values specified column(s) aggregated across directions undirected values.","code":""},{"path":[]},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/merge_directed_graph.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Merge directed edges into equivalent undirected edges. — merge_directed_graph","text":"","code":"graph <- weight_streetnet (hampi) from <- sample (graph$from_id, size = 10) to <- sample (graph$to_id, size = 5) to <- to [!to %in% from] flows <- matrix (10 * runif (length (from) * length (to)),     nrow = length (from) ) graph <- dodgr_flows_aggregate (graph, from = from, to = to, flows = flows) # graph then has an additonal 'flows` column of aggregate flows along all # edges. These flows are directed, and can be aggregated to equivalent # undirected flows on an equivalent undirected graph with: graph_undir <- merge_directed_graph (graph) # This graph will only include those edges having non-zero flows, and so: nrow (graph) #> [1] 6813 nrow (graph_undir) # the latter is much smaller #> [1] 844"},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/os_roads_bristol.html","id":null,"dir":"Reference","previous_headings":"","what":"Sample street network from Bristol, U.K. — os_roads_bristol","title":"Sample street network from Bristol, U.K. — os_roads_bristol","text":"sample street network Bristol, U.K., Ordnance Survey.","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/os_roads_bristol.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Sample street network from Bristol, U.K. — os_roads_bristol","text":"Simple Features sf data.frame representing motorways Bristol, UK.","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/os_roads_bristol.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Sample street network from Bristol, U.K. — os_roads_bristol","text":"Input data downloaded https://osdatahub.os.uk/downloads/open, download data page click tick box next 'OS Open Roads', scroll bottom, click 'Continue' complete form subsequent page. dataset open access can used licensing conditions, must cited follows: Contains OS data © Crown copyright database right (2017)","code":""},{"path":[]},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/os_roads_bristol.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Sample street network from Bristol, U.K. — os_roads_bristol","text":"","code":"if (FALSE) { # \\dontrun{ library (sf) library (dplyr) # data must be unzipped here # os_roads <- sf::read_sf(\"~/data/ST_RoadLink.shp\") # u <- paste0 ( #     \"https://opendata.arcgis.com/datasets/\", #     \"686603e943f948acaa13fb5d2b0f1275_4.kml\" # ) # lads <- sf::read_sf(u) # mapview::mapview(lads) # bristol_pol <- dplyr::filter(lads, grepl(\"Bristol\", lad16nm)) # os_roads <- st_transform(os_roads, st_crs(lads) # os_roads_bristol <- os_roads[bristol_pol, ] %>% #   dplyr::filter(class == \"Motorway\" & #                 roadNumber != \"M32\") %>% #   st_zm(drop = TRUE) # mapview::mapview(os_roads_bristol) } # } # Converting this 'sf data.frame' to a 'dodgr' network requires manual # specification of weighting profile: colnm <- \"formOfWay\" # name of column used to determine weights wts <- data.frame (     name = \"custom\",     way = unique (os_roads_bristol [[colnm]]),     value = c (0.1, 0.2, 0.8, 1) ) net <- weight_streetnet (     os_roads_bristol,     wt_profile = wts,     type_col = colnm, id_col = \"identifier\" ) # 'id_col' tells the function which column to use to attribute IDs of ways"},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/pipe.html","id":null,"dir":"Reference","previous_headings":"","what":"Pipe operator — %>%","title":"Pipe operator — %>%","text":"Pipe operator","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/pipe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pipe operator — %>%","text":"","code":"lhs %>% rhs"},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/summary.dodgr_dists_categorical.html","id":null,"dir":"Reference","previous_headings":"","what":"Transform a result from dodgr_dists_categorical to summary statistics — summary.dodgr_dists_categorical","title":"Transform a result from dodgr_dists_categorical to summary statistics — summary.dodgr_dists_categorical","text":"Transform result dodgr_dists_categorical summary statistics","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/summary.dodgr_dists_categorical.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Transform a result from dodgr_dists_categorical to summary statistics — summary.dodgr_dists_categorical","text":"","code":"# S3 method for class 'dodgr_dists_categorical' summary(object, ...)"},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/summary.dodgr_dists_categorical.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Transform a result from dodgr_dists_categorical to summary statistics — summary.dodgr_dists_categorical","text":"object 'dodgr_dists_categorical' object ... Extra parameters currently used","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/summary.dodgr_dists_categorical.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Transform a result from dodgr_dists_categorical to summary statistics — summary.dodgr_dists_categorical","text":"summary statistics (invisibly)","code":""},{"path":[]},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/weight_railway.html","id":null,"dir":"Reference","previous_headings":"","what":"Weight a network for routing along railways. — weight_railway","title":"Weight a network for routing along railways. — weight_railway","text":"Weight (re-weight) sf-formatted OSM street network routing along railways.","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/weight_railway.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Weight a network for routing along railways. — weight_railway","text":"","code":"weight_railway(   x,   type_col = \"railway\",   id_col = \"osm_id\",   keep_cols = c(\"maxspeed\"),   excluded = c(\"abandoned\", \"disused\", \"proposed\", \"razed\") )"},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/weight_railway.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Weight a network for routing along railways. — weight_railway","text":"x street network represented either sf LINESTRING objects, typically extracted dodgr_streetnet. type_col Specify column sf data.frame object designates different types railways used weighting (default works osmdata objects). id_col Specify column sf data.frame object provides unique identifiers railway (default works osmdata objects). keep_cols Vectors columns sf_lines kept resultant dodgr network; vector can either names indices desired columns. excluded Types railways exclude routing.","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/weight_railway.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Weight a network for routing along railways. — weight_railway","text":"data.frame edges representing rail network, along column graph component numbers.","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/weight_railway.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Weight a network for routing along railways. — weight_railway","text":"Default railway weighting distance. weighting schemes, maximum speed, can implemented simply modifying d_weighted column returned function accordingly.","code":""},{"path":[]},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/weight_railway.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Weight a network for routing along railways. — weight_railway","text":"","code":"if (FALSE) { # \\dontrun{ # sample railway extraction with the 'osmdata' package library (osmdata) dat <- opq (\"shinjuku\") %>%     add_osm_feature (key = \"railway\") %>%     osmdata_sf (quiet = FALSE) graph <- weight_railway (dat$osm_lines) } # }"},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/weight_streetnet.html","id":null,"dir":"Reference","previous_headings":"","what":"Weight a street network according to a specified weighting profile. — weight_streetnet","title":"Weight a street network according to a specified weighting profile. — weight_streetnet","text":"Weight (re-weight) sf silicate (\"SC\") formatted OSM street network according specified weighting  profile. Standard weighting profiles may specified name, one : foot horse wheelchair bicycle moped motorcycle motorcar goods hgv psv Custom weighting profiles also possible, explained Note .","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/weight_streetnet.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Weight a street network according to a specified weighting profile. — weight_streetnet","text":"","code":"weight_streetnet(   x,   wt_profile = \"bicycle\",   wt_profile_file = NULL,   turn_penalty = FALSE,   type_col = \"highway\",   id_col = \"osm_id\",   keep_cols = NULL,   left_side = FALSE )  # Default S3 method weight_streetnet(   x,   wt_profile = \"bicycle\",   wt_profile_file = NULL,   turn_penalty = FALSE,   type_col = \"highway\",   id_col = \"osm_id\",   keep_cols = NULL,   left_side = FALSE )  # S3 method for class 'sf' weight_streetnet(   x,   wt_profile = \"bicycle\",   wt_profile_file = NULL,   turn_penalty = FALSE,   type_col = \"highway\",   id_col = \"osm_id\",   keep_cols = NULL,   left_side = FALSE )  # S3 method for class 'sc' weight_streetnet(   x,   wt_profile = \"bicycle\",   wt_profile_file = NULL,   turn_penalty = FALSE,   type_col = \"highway\",   id_col = \"osm_id\",   keep_cols = NULL,   left_side = FALSE )  # S3 method for class 'SC' weight_streetnet(   x,   wt_profile = \"bicycle\",   wt_profile_file = NULL,   turn_penalty = FALSE,   type_col = \"highway\",   id_col = \"osm_id\",   keep_cols = NULL,   left_side = FALSE )"},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/weight_streetnet.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Weight a street network according to a specified weighting profile. — weight_streetnet","text":"x street network represented either sf LINESTRING objects, typically extracted dodgr_streetnet, SC (silicate) object typically extracted dodgr_streetnet_sc. wt_profile Name weighting profile, data.frame specifying custom values (see Details) wt_profile_file Name locally-stored, .json-formatted version dodgr::weighting_profiles, created write_dodgr_wt_profile, modified desired. turn_penalty Including time penalty edges turning across oncoming traffic intersections (see Note). type_col Specify column sf data.frame object designates different types highways used weighting (default works osmdata objects). id_col sf-formatted data : Specify column sf data.frame object provides unique identifiers highway (default works osmdata objects). keep_cols Vectors columns x kept resultant dodgr network; vector can either names, regex-patterns,  indices desired columns (see notes). left_side traffic travel left side road (TRUE) right side (FALSE)? - effect turn angle calculations edge times.","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/weight_streetnet.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Weight a street network according to a specified weighting profile. — weight_streetnet","text":"data.frame edges representing street network, distances metres times seconds, along column graph component numbers. Times sf-formatted street networks approximate, take account traffic lights, turn angles, elevation changes. Times sc-formatted street networks take account factors, elevation changes automatically taken account networks generated osmdata function osm_elevation().","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/weight_streetnet.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Weight a street network according to a specified weighting profile. — weight_streetnet","text":"Distances along edge calculated using geodist package, defaulting Mapbox \"cheap\" metric maximal network distances < 100km, otherwise using Haversine distances. dodgr_streetnet_geodesic function can called force edge distances calculated using accurate yet slower geodesic distances. structure networks generated function dependent many aspects input network, particular specific key-value pairs defined underlying OpenStreetMap (OSM) data. Many key-value pairs influence resultant network used specified weighting profiles. Keys used weighting profiles always kept weighted networks, specified weighting_profiles \"way\" column \"weighting_profiles\" item. include: \"bridleway\" \"cycleway\" \"ferry\" \"footway\" \"living_street\" \"motorway\" \"motorway_link \"path\" \"pedestrian\" \"primary\" \"primary_link\" \"residential\" \"secondary\" \"secondary_link \"service\" \"steps\" \"tertiary\" \"tertiary_link\" \"track\" \"trunk\" \"trunk_link \"unclassified\" optionally kept, dependent weighting profile chosen. example, \"cycleway\" keys kept bicycle weighting. specified keys also include possible variations keys. example \"cycleway\" , key-value pairs also kept \"cycleway:left\" \"cycleway:right\". following additional keys also automatically retained weighted networks: \"highway\" \"junction\" \"lanes\" \"maxspeed\" \"oneway\", including alternative forms \"oneway.bicycle\" \"surface\" Realistic routing including factors access restrictions, turn penalties, effects incline, can implemented objects passed weight_streetnet sc (\"silicate\") format, generated dodgr_streetnet_sc (possibly enhanced applying osmdata function osm_elevation()). Restrictions applied ways (OSM terminology) may controlled ensuring specific columns retained dodgr network keep_cols argument. example, restrictions access generally specified specifying value key \"access\". Include \"access\" keep_cols ensure values retained dodgr version, ways specified values can easily removed modified, demonstrated examples. Restrictions time-penalties turns can implemented setting turn_penalty = TRUE, honour turn restrictions specified OSM (unless \"penalties\" table weighting_profiles restrictions = FALSE specified wt_profile). Resultant graphs fundamentally different default distance-based routing. graphs may used directly 'dodgr' functions, generally created calling function session, saved loaded dodgr_save_streetnet dodgr_load_streetnet functions. (weighted streetnets also accompanying data stored local temporary cache directory; attempting pass weighted street network without accompanying cache files generally error.) key-value pairs may also directly influence just value graph produced function, also size. Among \"oneway\" flags. Without flags, edge represented directed form, two rows graph: one -> B, one B -> . way tagged OSM \"oneway\" = \"yes\", oneway flags respected chosen weighting profile (, example, generally pedestrian \"foot\" weighting), one edge returned representing travel direction permitted within OSM data. Thus weighting network includes \"oneway\" flags, using weighting profile respects , generate graph fewer rows graph produced ignoring \"oneway\" flags.","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/weight_streetnet.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Weight a street network according to a specified weighting profile. — weight_streetnet","text":"Names wt_profile parameter taken weighting_profiles, list including data.frame also called weighting_profiles weights different modes transport. Values wt_profile taken current modes included , \"bicycle\", \"foot\", \"goods\", \"hgv\", \"horse\", \"moped\", \"motorcar\", \"motorcycle\", \"psv\", \"wheelchair\". Railway routing can implemented separate function weight_railway. Alternatively, entire weighting_profile structures can written local .json-formatted file write_dodgr_wt_profile, values edited desired, name file passed wt_profile_file parameter. resultant graph includes edges given weighting profile specifies finite edge weights. edges types present given weighting profile automatically removed weighted streetnet. resultant graph contracted via dodgr_contract_graph, columns graph , , modified, automatic caching must switched dodgr_cache_off. , dodgr_contract_graph function return automatically cached version, contracted version full graph prior modification columns.","code":""},{"path":[]},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/weight_streetnet.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Weight a street network according to a specified weighting profile. — weight_streetnet","text":"","code":"# hampi is included with package as an 'osmdata' sf-formatted street network net <- weight_streetnet (hampi) class (net) # data.frame #> [1] \"dodgr_streetnet\" \"data.frame\"      dim (net) # 6096  11; 6096 streets #> [1] 6813   16 # os_roads_bristol is also included as an sf data.frame, but in a different # format requiring identification of columns and specification of custom # weighting scheme. colnm <- \"formOfWay\" wts <- data.frame (     name = \"custom\",     way = unique (os_roads_bristol [[colnm]]),     value = c (0.1, 0.2, 0.8, 1) ) net <- weight_streetnet (     os_roads_bristol,     wt_profile = wts,     type_col = colnm, id_col = \"identifier\" ) dim (net) # 406 11; 406 streets #> [1] 812  16  # An example for a generic (non-OSM) highway, represented as the # `routes_fast` object of the \\pkg{stplanr} package, which is a # SpatialLinesDataFrame. if (FALSE) { # \\dontrun{ library (stplanr) # merge all of the 'routes_fast' lines into a single network r <- overline (routes_fast, attrib = \"length\", buff_dist = 1) r <- sf::st_as_sf (r, crs = 4326) # We need to specify both a `type` and `id` column for the # \\link{weight_streetnet} function. r$type <- 1 r$id <- seq (nrow (r)) graph <- weight_streetnet (     r,     type_col = \"type\",     id_col = \"id\",     wt_profile = 1 ) } # }"},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/weighting_profiles.html","id":null,"dir":"Reference","previous_headings":"","what":"Weighting profiles used to route different modes of transport. — weighting_profiles","title":"Weighting profiles used to route different modes of transport. — weighting_profiles","text":"Collection weighting profiles used adjust routing process different means transport. Modified data taken Routino project, additional tables average speeds, dependence speed type surface, waiting times seconds traffic lights. latter table (called \"penalties\") includes waiting times traffic lights (seconds), additional time penalties turning across oncoming traffic (\"turn\"), binary flag indicating whether turn restrictions obeyed .","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/weighting_profiles.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Weighting profiles used to route different modes of transport. — weighting_profiles","text":"List data.frame objects profile names, means transport weights.","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/weighting_profiles.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Weighting profiles used to route different modes of transport. — weighting_profiles","text":"https://www.routino.org/xml/routino-profiles.xml","code":""},{"path":[]},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/write_dodgr_wt_profile.html","id":null,"dir":"Reference","previous_headings":"","what":"Write dodgr weighting profiles to local file. — write_dodgr_wt_profile","title":"Write dodgr weighting profiles to local file. — write_dodgr_wt_profile","text":"Write dodgr street network weighting profiles local .json-formatted file manual editing subsequent re-reading.","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/write_dodgr_wt_profile.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Write dodgr weighting profiles to local file. — write_dodgr_wt_profile","text":"","code":"write_dodgr_wt_profile(file = NULL)"},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/write_dodgr_wt_profile.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Write dodgr weighting profiles to local file. — write_dodgr_wt_profile","text":"file Full name (including path) file write. .json suffix automatically appended.","code":""},{"path":"https://UrbanAnalyst.github.io/dodgr/reference/write_dodgr_wt_profile.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Write dodgr weighting profiles to local file. — write_dodgr_wt_profile","text":"TRUE writing successful.","code":""},{"path":[]}]
